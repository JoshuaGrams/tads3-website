<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>travel.t</title></head><body>
<table class=ban><tr><td><h1>travel.t</h1><td align=right><a href="../file/travel.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#include "advlite.h"
<a name="3"></a>
<a name="4"></a>
<a name="5"></a>/*
<a name="6"></a> *   ****************************************************************************
<a name="7"></a> *    room.t 
<a name="8"></a> *    This module forms part of the adv3Lite library 
<a name="9"></a> *    (c) 2012-13 Eric Eve
<a name="10"></a> */
<a name="11"></a>
<a name="12"></a>property lastTravelInfo;
<a name="13"></a>property cannotGoShowExits;
<a name="14"></a>
<a name="15"></a>/* 
<a name="16"></a> *   A Room is a top location in which the player character, other actors and
<a name="17"></a> *   other objects may be located. It may represent any discrete unit of space,
<a name="18"></a> *   not necessarily a room in a building. Normally actors may only interact
<a name="19"></a> *   with objects in the same room as themselves, but the senseRegion module
<a name="20"></a> *   allows us to define sensory connections between rooms.
<a name="21"></a> */     
<a name="22"></a>class Room: TravelConnector, Thing
<a name="23"></a>    
<a name="24"></a>    
<a name="25"></a>    /*  
<a name="26"></a>     *   The direction properties (north, south, etc.) define what happens when
<a name="27"></a>     *   travel is attempted in the corresponding direction. A direction
<a name="28"></a>     *   property may be defined as another Room (in which case traveling in the
<a name="29"></a>     *   corresponding direction takes the actor directly to that Room), or to a
<a name="30"></a>     *   TravelConnector (including a Door or Stairway), or to a single-quoted
<a name="31"></a>     *   or double-quoted string (which is then simply displayed) or to a method
<a name="32"></a>     *   (which is then executed). It is recommended that methods only be used
<a name="33"></a>     *   when the effect of attempted travel is something other than ordinary
<a name="34"></a>     *   travel; to impose conditions on travel or define the side-effects of
<a name="35"></a>     *   travel it's usually better to use a TravelConnector object.
<a name="36"></a>     */
<a name="37"></a>    north = nil
<a name="38"></a>    east = nil
<a name="39"></a>    south = nil
<a name="40"></a>    west = nil
<a name="41"></a>    up = nil
<a name="42"></a>    down = nil
<a name="43"></a>    in = nil
<a name="44"></a>    out = nil
<a name="45"></a>    southeast = nil
<a name="46"></a>    southwest = nil
<a name="47"></a>    northeast = nil
<a name="48"></a>    northwest = nil
<a name="49"></a>    port = nil
<a name="50"></a>    starboard = nil
<a name="51"></a>    aft = nil
<a name="52"></a>    fore = nil
<a name="53"></a>    
<a name="54"></a>    /*
<a name="55"></a>     *   Are compass directions allowed for travel from this room? By default
<a name="56"></a>     *   we'll allow thema anywhere, but game code may wish to override this for
<a name="57"></a>     *   rooms that are aboard a vessel.
<a name="58"></a>     */
<a name="59"></a>    allowCompassDirections = true
<a name="60"></a>    
<a name="61"></a>    /*
<a name="62"></a>     *   Are shipboard directions meaningful in this room? By default we'll make
<a name="63"></a>     *   them so if and  only if this room defines at least one shipboard
<a name="64"></a>     *   directional exit. Game code may wish to modify this, for example, on
<a name="65"></a>     *   the hold of a ship that only defines an up direction but where
<a name="66"></a>     *   shipboard directions would still in principle be meaningful.
<a name="67"></a>     */
<a name="68"></a>    allowShipboardDirections()
<a name="69"></a>    {
<a name="70"></a>        for(local dir in ShipboardDirection.shipboardDirections)
<a name="71"></a>        {
<a name="72"></a>            if(propType(dir.dirProp) != TypeNil)
<a name="73"></a>                return true;
<a name="74"></a>        }
<a name="75"></a>        
<a name="76"></a>        return nil;
<a name="77"></a>    }
<a name="78"></a>    
<a name="79"></a>	
<a name="80"></a>	
<a name="81"></a>    /* 
<a name="82"></a>     *   A Room is normally lit, but if we want a dark room we can override
<a name="83"></a>     *   isLit to nil.
<a name="84"></a>     */   
<a name="85"></a>    isLit = true
<a name="86"></a>    
<a name="87"></a>    /*   A Room is always fixed in place. */
<a name="88"></a>    isFixed = true
<a name="89"></a>    
<a name="90"></a>    /*   A Room is always open */
<a name="91"></a>    isOpen = true
<a name="92"></a>    
<a name="93"></a>    /*   
<a name="94"></a>     *   A Room is lit within it it's illuminated (it's either lit itself or
<a name="95"></a>     *   contains a light source
<a name="96"></a>     */
<a name="97"></a>    litWithin()
<a name="98"></a>    {
<a name="99"></a>        return isIlluminated;
<a name="100"></a>    }
<a name="101"></a>    
<a name="102"></a>    
<a name="103"></a>    /*   
<a name="104"></a>     *   Since a Room provides the TravelConnector interface, we need to define
<a name="105"></a>     *   where it leads to when one attempts to travel via it; a Room always
<a name="106"></a>     *   leads to itself (i.e. traveling via a Room takes one to that Room).
<a name="107"></a>     */
<a name="108"></a>    destination { return self; }
<a name="109"></a>    
<a name="110"></a>    /* By default our destination is known if we've been visited */
<a name="111"></a>    isDestinationKnown = (visited)
<a name="112"></a>    
<a name="113"></a>    /* Has this room been visited? */
<a name="114"></a>    visited = nil
<a name="115"></a> 
<a name="116"></a>    /* 
<a name="117"></a>     *   Although we don't define room parts in general, we do give every Room a
<a name="118"></a>     *   floor so that the parser can refer to objects 'on the ground' when
<a name="119"></a>     *   asking disambiguation questions. By default we supply every Room with
<a name="120"></a>     *   the defaultGround MultiLoc object to represent its floor. You can if
<a name="121"></a>     *   you like replace this with a custom floor object in particular rooms,
<a name="122"></a>     *   but it's highly recommended that you define your custom floor to be of
<a name="123"></a>     *   the Floor class. It's also legal to define floorObj as nil on a Room
<a name="124"></a>     *   that represents an obviously floorless place, such as the top of a mast
<a name="125"></a>     *   or tree.
<a name="126"></a>     */
<a name="127"></a>    floorObj = defaultGround       
<a name="128"></a>    
<a name="129"></a>    /* 
<a name="130"></a>     *   When executing travel we move the traveler into the room. Then, if the
<a name="131"></a>     *   traveler is the player char we perform a look around in the room,
<a name="132"></a>     *   provided we should look around on entering the room. actor is the actor
<a name="133"></a>     *   doing the traveling, traveler is the traveler doing the traveling
<a name="134"></a>     *   (normally the same as actor unless actor is in a Vehicle, in which case
<a name="135"></a>     *   traveler will be the Vehicle) and conn is the TravelConnector the
<a name="136"></a>     *   vehicle is traversing in order to reach this room.
<a name="137"></a>     */     
<a name="138"></a>    execTravel(actor, traveler, conn)
<a name="139"></a>    {        
<a name="140"></a>        /*   Note whether we want to look around on entering this room. */
<a name="141"></a>        local lookAroundOnEntering = lookOnEnter(actor);
<a name="142"></a>        
<a name="143"></a>        /* 
<a name="144"></a>         *   Note the traveler's current location, so we can check subsequently
<a name="145"></a>         *   whether travel actually took place.
<a name="146"></a>         */
<a name="147"></a>        local oldLoc = traveler.getOutermostRoom();
<a name="148"></a>        
<a name="149"></a>        /*   
<a name="150"></a>         *   Get our destination when starting from oldLoc (for a room this
<a name="151"></a>         *   should normally evaluate to self)
<a name="152"></a>         */
<a name="153"></a>        local dest = getDestination(oldLoc);
<a name="154"></a>        
<a name="155"></a>        /*  Carry out the before travel notification */
<a name="156"></a>        conn.beforeTravelNotifications(traveler);
<a name="157"></a>        
<a name="158"></a>        /* 
<a name="159"></a>         *   Note the actor's old travel info in case we have to restore it
<a name="160"></a>         *   after a failed travel attempt.
<a name="161"></a>         */
<a name="162"></a>        if(actor != gPlayerChar)
<a name="163"></a>            local oldTravelInfo = actor.lastTravelInfo;
<a name="164"></a>        
<a name="165"></a>        if(actor == gPlayerChar)
<a name="166"></a>        {                  
<a name="167"></a>            /* 
<a name="168"></a>             *   Before carrying out the travel make a note of the room the
<a name="169"></a>             *   player character is about to leave.
<a name="170"></a>             */
<a name="171"></a>            libGlobal.lastLoc = oldLoc;                               
<a name="172"></a>        }
<a name="173"></a>        
<a name="174"></a>        /* 
<a name="175"></a>         *   Otherwise if the player character can see the actor traverse the
<a name="176"></a>         *   connector, note the fact on the actor, so that the information is
<a name="177"></a>         *   available should the player character wish to follow the actor.
<a name="178"></a>         */
<a name="179"></a>        else if(Q.canSee(gPlayerChar, actor))
<a name="180"></a>            actor.lastTravelInfo = [oldLoc, conn];
<a name="181"></a>        
<a name="182"></a>        /*   
<a name="183"></a>         *   Note that actor is traversing the Travel Connector. This can be
<a name="184"></a>         *   used to carry out any side-effects of the travel, such as
<a name="185"></a>         *   describing it.
<a name="186"></a>         */             
<a name="187"></a>        
<a name="188"></a>        conn.noteTraversal(actor); 
<a name="189"></a>        
<a name="190"></a>        /* Notify the actor's current room that the actor is about to depart. */
<a name="191"></a>        oldLoc.notifyDeparture(actor, dest);
<a name="192"></a>        
<a name="193"></a>        /*  Move the traveling object into its destination */
<a name="194"></a>        traveler.actionMoveInto(dest);
<a name="195"></a>        
<a name="196"></a>        if(gPlayerChar.isOrIsIn(traveler))
<a name="197"></a>        {
<a name="198"></a>            /* 
<a name="199"></a>             *   Notify any actors in the location that the player character has
<a name="200"></a>             *   just arrived.
<a name="201"></a>             */
<a name="202"></a>            
<a name="203"></a>            local notifyList = allContents.subset({o: o.ofKind(Actor)});
<a name="204"></a>            
<a name="205"></a>            notifyList.forEach({a: a.pcArrivalTurn = gTurns });
<a name="206"></a>            
<a name="207"></a>            /* Show a room description if appropriate */
<a name="208"></a>            if(lookAroundOnEntering)
<a name="209"></a>                lookAroundWithin();
<a name="210"></a>        }
<a name="211"></a>        
<a name="212"></a>        /*  
<a name="213"></a>         *   Execute the after travel notifications, provided that the actor
<a name="214"></a>         *   actually ended up in a new location.
<a name="215"></a>         */
<a name="216"></a>        if(self != oldLoc)
<a name="217"></a>        {               
<a name="218"></a>            conn.afterTravelNotifications(traveler);
<a name="219"></a>        }
<a name="220"></a>        
<a name="221"></a>        /* 
<a name="222"></a>         *   If we're not the player character and we failed to go anywhere,
<a name="223"></a>         *   restore our old travel info.
<a name="224"></a>         */
<a name="225"></a>        if(actor != gPlayerChar &amp;&amp; actor.getOutermostRoom == oldLoc)
<a name="226"></a>            actor.lastTravelInfo = oldTravelInfo;
<a name="227"></a>    }
<a name="228"></a>    
<a name="229"></a>    /* 
<a name="230"></a>     *   Should we look around on entering this room? By default we should; this
<a name="231"></a>     *   is overridden in senseRegion.t to provide for the possibility of a
<a name="232"></a>     *   "continuous space" implementation.
<a name="233"></a>     */
<a name="234"></a>    lookOnEnter(obj)
<a name="235"></a>    {
<a name="236"></a>        return true;
<a name="237"></a>    }
<a name="238"></a>    
<a name="239"></a>    
<a name="240"></a>    
<a name="241"></a>    /*  A Room's outermost room is itself. */
<a name="242"></a>    getOutermostRoom { return self; }
<a name="243"></a>    
<a name="244"></a>    /* 
<a name="245"></a>     *   The Message to display if travel is disallowed in any given direction
<a name="246"></a>     *   (because the corresponding direction property of the Room is nil).
<a name="247"></a>     */    
<a name="248"></a>    cannotGoThatWayMsg = BMsg(cannot go, '{I} {can\'t} go that way. ' )
<a name="249"></a>    
<a name="250"></a>    /*   
<a name="251"></a>     *   The method that is called when travel is attempted in a direction
<a name="252"></a>     *   (given the dir parameter) for which nothing is defined. By default we
<a name="253"></a>     *   simply display the cannotGoThatWayMsg followed by a list of exits, but
<a name="254"></a>     *   this can be overridden if desired, and different responses given for
<a name="255"></a>     *   different directions. Note that the dir parameter will be passed as a
<a name="256"></a>     *   direction object. e.g. northDir.
<a name="257"></a>     */
<a name="258"></a>    cannotGoThatWay(dir)
<a name="259"></a>    {
<a name="260"></a>        "&lt;&lt;cannotGoThatWayMsg&gt;&gt;";
<a name="261"></a>        if(gExitLister != nil)
<a name="262"></a>            gExitLister.cannotGoShowExits(gActor, self);
<a name="263"></a>        
<a name="264"></a>        "&lt;.p&gt;";
<a name="265"></a>    }
<a name="266"></a>    
<a name="267"></a>    /*  
<a name="268"></a>     *   The message to display when travel is attempted in the dark, either in
<a name="269"></a>     *   a direction for which no destination (or other handling) is defined, or
<a name="270"></a>     *   in a direction in which the exit is not visible in the dark.
<a name="271"></a>     */
<a name="272"></a>    cannotGoThatWayInDarkMsg = BMsg(cannot go in dark, 'It{dummy}{\'s} too dark
<a name="273"></a>        to see where {i}{\'m} going. ')
<a name="274"></a>    
<a name="275"></a>    
<a name="276"></a>    /*   
<a name="277"></a>     *   The method that's called when travel is attempted by an undefined or
<a name="278"></a>     *   invisible exit in the dark. By default we display the
<a name="279"></a>     *   cannotGoThatWayInDarkMsg followed by a list of visible exits, but game
<a name="280"></a>     *   code can override this.
<a name="281"></a>     */
<a name="282"></a>    cannotGoThatWayInDark(dir)
<a name="283"></a>    {
<a name="284"></a>        "&lt;&lt;cannotGoThatWayInDarkMsg&gt;&gt;&lt;.p&gt;";
<a name="285"></a>        if(gExitLister != nil)
<a name="286"></a>            gExitLister.cannotGoShowExits(gActor, self);
<a name="287"></a>        
<a name="288"></a>        "&lt;.p&gt;";
<a name="289"></a>    }
<a name="290"></a>                                    
<a name="291"></a>    
<a name="292"></a>    /* 
<a name="293"></a>     *   Normally we don't allow travel from this location if both it and the
<a name="294"></a>     *   destination are in darkness. To allow travel from this location in any
<a name="295"></a>     *   case set allowDarkTravel to true.
<a name="296"></a>     */    
<a name="297"></a>    allowDarkTravel = nil
<a name="298"></a>    
<a name="299"></a>       
<a name="300"></a>    
<a name="301"></a>    /* Call the before action notifications on this room and its regions */
<a name="302"></a>    notifyBefore()
<a name="303"></a>    {
<a name="304"></a>        /* Call our own roomBeforeAction() */
<a name="305"></a>        roomBeforeAction();
<a name="306"></a>        
<a name="307"></a>        /* 
<a name="308"></a>         *   Notify all the regions we're in of the action that's about to take
<a name="309"></a>         *   place.
<a name="310"></a>         */
<a name="311"></a>        foreach(local reg in valToList(regions))
<a name="312"></a>            reg.notifyBefore();
<a name="313"></a>    }
<a name="314"></a>    
<a name="315"></a>    /* Call the after action notifications on this room and its regions */
<a name="316"></a>    notifyAfter()
<a name="317"></a>    {
<a name="318"></a>        /* Call our own roomAfterAction() */
<a name="319"></a>        roomAfterAction();
<a name="320"></a>        
<a name="321"></a>        /* 
<a name="322"></a>         *   Notify all the regions we're in of the action that's just taken
<a name="323"></a>         *   place.
<a name="324"></a>         */
<a name="325"></a>        foreach(local reg in valToList(regions))
<a name="326"></a>            reg.notifyAfter();
<a name="327"></a>    }
<a name="328"></a>    
<a name="329"></a>    
<a name="330"></a>    /* 
<a name="331"></a>     *   roomBeforeAction and roomAfterAction are called just before and after
<a name="332"></a>     *   the action phases of the current action. Individual instances can
<a name="333"></a>     *   override to react to the particular actions.     */
<a name="334"></a>    
<a name="335"></a>    roomBeforeAction() { }
<a name="336"></a>    roomAfterAction() { }
<a name="337"></a>   
<a name="338"></a>    
<a name="339"></a>    /*   
<a name="340"></a>     *   beforeTravel(traveler, connector) is called on the room traveler is
<a name="341"></a>     *   in just as traveler is about to attempt travel via connector (a
<a name="342"></a>     *   TravelConnector object).
<a name="343"></a>     */
<a name="344"></a>    beforeTravel(traveler, connector) { }
<a name="345"></a>    
<a name="346"></a>    /*   
<a name="347"></a>     *   afterTravel(traveler, connector) is called on the room traveler has
<a name="348"></a>     *   just arrived in via connector.
<a name="349"></a>     */
<a name="350"></a>    afterTravel(traveler, connector) { }
<a name="351"></a>    
<a name="352"></a>    
<a name="353"></a>    /* show the exit list in the status line */
<a name="354"></a>    showStatuslineExits()
<a name="355"></a>    {
<a name="356"></a>        /* if we have a global exit lister, ask it to show the exits */
<a name="357"></a>        if (gExitLister != nil)
<a name="358"></a>            gExitLister.showStatuslineExits();
<a name="359"></a>    }
<a name="360"></a>
<a name="361"></a>    
<a name="362"></a>    /*  The name of the room as it appears in the status line. */
<a name="363"></a>    statusName(actor)
<a name="364"></a>    {
<a name="365"></a>        local nestedLoc = '';
<a name="366"></a>        
<a name="367"></a>        /*  
<a name="368"></a>         *   If the actor is not directly in the room we add the actor's
<a name="369"></a>         *   immediate container in parentheses after the room name.
<a name="370"></a>         */
<a name="371"></a>        if(!actor.location.ofKind(Room))
<a name="372"></a>            nestedLoc = BMsg(actor nested location name,  
<a name="373"></a>                             ' (&lt;&lt;actor.location.objInPrep&gt;&gt; 
<a name="374"></a>                &lt;&lt;actor.location.theName&gt;&gt;)');
<a name="375"></a>        
<a name="376"></a>        /*  
<a name="377"></a>         *   If the Room is illuminated, display its ordinary room title,
<a name="378"></a>         *   followed by the actor's immediate location if it's not the Room. If
<a name="379"></a>         *   the Room is in darkness, use the darkName instead of the roomTitle.
<a name="380"></a>         */
<a name="381"></a>        if(isIlluminated)
<a name="382"></a>            "&lt;&lt;roomTitle&gt;&gt;&lt;&lt;nestedLoc&gt;&gt;";
<a name="383"></a>        else
<a name="384"></a>            "&lt;&lt;darkName&gt;&gt;&lt;&lt;nestedLoc&gt;&gt;";
<a name="385"></a>    }
<a name="386"></a>    
<a name="387"></a>    /*  
<a name="388"></a>     *   Anything in the Room is deemed to be inside it (this sounds
<a name="389"></a>     *   tautologous, but it's why we give Room a contType of In).
<a name="390"></a>     */
<a name="391"></a>    contType = In
<a name="392"></a>    
<a name="393"></a>    /* 
<a name="394"></a>     *   This method is invoked on the player char's current room at the end of
<a name="395"></a>     *   every action. By default we run our doScript() method if we're also a
<a name="396"></a>     *   Script (that is, if the Room has been mixed in with an EventList
<a name="397"></a>     *   class), thereby facilitating the display of atmospheric messages.
<a name="398"></a>     */    
<a name="399"></a>    roomDaemon() 
<a name="400"></a>    {
<a name="401"></a>        if(ofKind(Script))
<a name="402"></a>            doScript();
<a name="403"></a>    }
<a name="404"></a>    
<a name="405"></a>    
<a name="406"></a>    /* 
<a name="407"></a>     *   This room can optionally be in one or more regions. The regions
<a name="408"></a>     *   property hold the region or a list of regions I'm in.
<a name="409"></a>     */    
<a name="410"></a>    regions = nil
<a name="411"></a>    
<a name="412"></a>    /* 
<a name="413"></a>     *   A Room can't be in another Room or a Thing, but it can notionally be in
<a name="414"></a>     *   a Region, so we check to see if we're in the list of our regions.
<a name="415"></a>     */    
<a name="416"></a>    isIn(region)
<a name="417"></a>    {
<a name="418"></a>        return valToList(regions).indexWhich({x: x.isOrIsIn(region)}) != nil;
<a name="419"></a>    }
<a name="420"></a>    
<a name="421"></a>    /* Add this room to the room list of all the regions it's in */    
<a name="422"></a>    addToRegions()
<a name="423"></a>    {
<a name="424"></a>        foreach(local reg in valToList(regions))
<a name="425"></a>            reg.addToRoomList(self);
<a name="426"></a>    }
<a name="427"></a>    
<a name="428"></a>    /* 
<a name="429"></a>     *   The list of all the regions this room belongs to. This is calculated
<a name="430"></a>     *   the first time this property is queried and then stored in the
<a name="431"></a>     *   property.
<a name="432"></a>     */    
<a name="433"></a>    allRegions()
<a name="434"></a>    {
<a name="435"></a>        local ar = getAllRegions();
<a name="436"></a>        allRegions = ar;
<a name="437"></a>        return ar;        
<a name="438"></a>    }
<a name="439"></a>    
<a name="440"></a>    /* Calculate a list of all the regions this room belongs to */
<a name="441"></a>    getAllRegions()
<a name="442"></a>    {
<a name="443"></a>        local thisRegions = new Vector(valToList(regions));
<a name="444"></a>        foreach(local reg in valToList(regions))
<a name="445"></a>            thisRegions.appendUnique(reg.allRegions);
<a name="446"></a>        
<a name="447"></a>        return thisRegions.toList();
<a name="448"></a>    }
<a name="449"></a>    
<a name="450"></a>    
<a name="451"></a>    /* return a list of regions that both this room and other are common to. */    
<a name="452"></a>    regionsInCommonWith(other)
<a name="453"></a>    {
<a name="454"></a>        return allRegions.subset({x: x.roomList.indexOf(other) != nil});        
<a name="455"></a>    }
<a name="456"></a>    
<a name="457"></a>    /* 
<a name="458"></a>     *   Carry out the notifications for a traveler leaving this room to go to
<a name="459"></a>     *   dest.
<a name="460"></a>     */
<a name="461"></a>    notifyDeparture(traveler, dest)
<a name="462"></a>    {
<a name="463"></a>        /* Notify the current room of the impending departure */
<a name="464"></a>        travelerLeaving(traveler, dest);
<a name="465"></a>        
<a name="466"></a>                
<a name="467"></a>        /* 
<a name="468"></a>         *   Notify any regions the traveler is about to leave of the impending
<a name="469"></a>         *   departure         */
<a name="470"></a>        
<a name="471"></a>        local commonRegs = regionsInCommonWith(dest);
<a name="472"></a>        
<a name="473"></a>        /* 
<a name="474"></a>         *   The regions I'm about to leave are all the regions this room is in
<a name="475"></a>         *   less those that this room has in common with my destination.
<a name="476"></a>         */
<a name="477"></a>        local regsLeft = allRegions - commonRegs;
<a name="478"></a>        
<a name="479"></a>        
<a name="480"></a>        /*   
<a name="481"></a>         *   Notify all the regions that the traveler is leaving that the
<a name="482"></a>         *   traveler is leaving to go to dest.
<a name="483"></a>         */
<a name="484"></a>        foreach(local reg in regsLeft)
<a name="485"></a>            reg.travelerLeaving(traveler, dest);
<a name="486"></a>        
<a name="487"></a>        /* 
<a name="488"></a>         *   The regions I'm about to enter are all the regions the destination
<a name="489"></a>         *   room is in, less those this room has in common with the
<a name="490"></a>         *   destination.
<a name="491"></a>         */        
<a name="492"></a>        local regsEntered = dest.allRegions - commonRegs;
<a name="493"></a>        
<a name="494"></a>        
<a name="495"></a>        /* Notify any regions I'm about to enter of my impending arrival. */
<a name="496"></a>        foreach(local reg in regsEntered)
<a name="497"></a>            reg.travelerEntering(traveler, self);
<a name="498"></a>        
<a name="499"></a>        /* notify the destination room of the impending arrival */        
<a name="500"></a>        dest.travelerEntering(traveler, self);
<a name="501"></a>    }
<a name="502"></a>    
<a name="503"></a>    
<a name="504"></a>    /* 
<a name="505"></a>     *   This method is invoked when traveler is about to leave this room and go
<a name="506"></a>     *   to dest.
<a name="507"></a>     */
<a name="508"></a>    travelerLeaving(traveler, dest) { }
<a name="509"></a>    
<a name="510"></a>    /* 
<a name="511"></a>     *   This method is invoked when traveler is about to enter this room 
<a name="512"></a>     *   from origin.
<a name="513"></a>     */
<a name="514"></a>    travelerEntering(traveler, origin) { }
<a name="515"></a>    
<a name="516"></a>   
<a name="517"></a>    /*    A Room has no interiorParent since it's a top-level container. */
<a name="518"></a>    interiorParent()
<a name="519"></a>    {
<a name="520"></a>        return nil;
<a name="521"></a>    }
<a name="522"></a>    
<a name="523"></a>    /* 
<a name="524"></a>     *   Add extra items into scope for the action. By default we simply add the
<a name="525"></a>     *   items from our extraScopeItems list together with those of any regions
<a name="526"></a>     *   we're it. This allows commonly visible items such as the sky to be
<a name="527"></a>     *   added to scope in dark outdoor rooms, for instance.
<a name="528"></a>     */    
<a name="529"></a>    addExtraScopeItems(action)
<a name="530"></a>    {
<a name="531"></a>        /* 
<a name="532"></a>         *   Append the extra scope items defined on this Room to the action's
<a name="533"></a>         *   scope list.
<a name="534"></a>         */
<a name="535"></a>        action.scopeList =
<a name="536"></a>            action.scopeList.appendUnique(valToList(extraScopeItems));
<a name="537"></a>        
<a name="538"></a>        /*  Add any extra scope items defined on any regions we're in. */
<a name="539"></a>        foreach(local reg in valToList(regions))
<a name="540"></a>            reg.addExtraScopeItems(action);
<a name="541"></a>        
<a name="542"></a>        /* 
<a name="543"></a>         *   By default we'll also add our floor object to scope if we have one
<a name="544"></a>         *   and it isn't already in scope.
<a name="545"></a>         */        
<a name="546"></a>        if(floorObj != nil)
<a name="547"></a>            action.scopeList = action.scopeList.appendUnique([floorObj]);
<a name="548"></a>    }
<a name="549"></a>    
<a name="550"></a>    /*  
<a name="551"></a>     *   A list of extra items to be added to scope when an action is carried
<a name="552"></a>     *   out in this room.
<a name="553"></a>     */
<a name="554"></a>    extraScopeItems = []
<a name="555"></a>    
<a name="556"></a>    /*   The location at which a Room was last seen is always itself. */
<a name="557"></a>    lastSeenAt = (self)
<a name="558"></a>    
<a name="559"></a>    /* 
<a name="560"></a>     *   Convenience method to set information about the destination dirn from
<a name="561"></a>     *   this room. The dirn parameter should be specified as a direction object
<a name="562"></a>     *   (e.g. northDir) and the dest parameter as a room. Note this is only
<a name="563"></a>     *   meaningful for direction properties specified as methods (as opposed to
<a name="564"></a>     *   Rooms, Doors or other TravelConnectors or as strings), and is only
<a name="565"></a>     *   useful for priming the route finder at the start of the game before the
<a name="566"></a>     *   player has tried to go in this direction from this room. Once the
<a name="567"></a>     *   player tries this direction the dest info table will be overwritten
<a name="568"></a>     *   with information about where it actually leads.
<a name="569"></a>     */    
<a name="570"></a>    setDestInfo(dirn, dest)
<a name="571"></a>    {
<a name="572"></a>        libGlobal.addExtraDestInfo(self, dirn, dest);
<a name="573"></a>    }
<a name="574"></a>    
<a name="575"></a>    /* 
<a name="576"></a>     *   The getDirection method returns the direction by which one would need
<a name="577"></a>     *   to travel from this room to travel via the connector conn (or nil if
<a name="578"></a>     *   none of the room's direction properties point to conn).
<a name="579"></a>     */
<a name="580"></a>    getDirection(conn)
<a name="581"></a>    {
<a name="582"></a>        for(local dir = firstObj(Direction); dir != nil; dir = nextObj(dir,
<a name="583"></a>            Direction))
<a name="584"></a>        {
<a name="585"></a>            if(propType(dir.dirProp) == TypeObject &amp;&amp; self.(dir.dirProp) == conn)
<a name="586"></a>                return dir;
<a name="587"></a>        }
<a name="588"></a>        
<a name="589"></a>        return nil;
<a name="590"></a>    }
<a name="591"></a>    
<a name="592"></a>    /* 
<a name="593"></a>     *   By default we don't want the examineStatus method of a Room to do
<a name="594"></a>     *   anything except displaying the stateDesc, should we have defined one.
<a name="595"></a>     *   In particular we don't want it to list the contents of the Room, since
<a name="596"></a>     *   Looking Around will do this anyway.
<a name="597"></a>     */
<a name="598"></a>    examineStatus() { display(&amp;stateDesc); }
<a name="599"></a>
<a name="600"></a>    /*  Examining a Room is the same as looking around within it. */
<a name="601"></a>    dobjFor(Examine)
<a name="602"></a>    {
<a name="603"></a>        action() { lookAroundWithin(); }
<a name="604"></a>    }
<a name="605"></a>
<a name="606"></a>    /*  Going out of a Room is the same as executing an OUT command */
<a name="607"></a>    dobjFor(GetOutOf)
<a name="608"></a>    {
<a name="609"></a>        action() { GoOut.execAction(gCommand); }
<a name="610"></a>    }
<a name="611"></a>    
<a name="612"></a>    /*  
<a name="613"></a>     *   Pushing an object out of a Room is the same as pushing it via the OUT
<a name="614"></a>     *   exit.
<a name="615"></a>     */
<a name="616"></a>    iobjFor(PushTravelGetOutOf)
<a name="617"></a>    {
<a name="618"></a>        action()
<a name="619"></a>        {
<a name="620"></a>            gCommand.verbProd.dirMatch = object { dir = outDir; };
<a name="621"></a>            gAction = PushTravelDir;
<a name="622"></a>            PushTravelDir.execAction(gCommand);
<a name="623"></a>        }
<a name="624"></a>    }
<a name="625"></a> 
<a name="626"></a>    /* 
<a name="627"></a>     *   Optional method that returns a single-quoted string explaining why
<a name="628"></a>     *   target (normally an object in a remote location) cannot be reached from
<a name="629"></a>     *   this room. By default we just return the target's tooFarAwayMsg but
<a name="630"></a>     *   this can be overridden, for example, to return the same format of
<a name="631"></a>     *   message for every target that can't be reached from this room (e.g.
<a name="632"></a>     *   "You can't reach [the target] from the meadow. ") ]
<a name="633"></a>     */        
<a name="634"></a>        
<a name="635"></a>    cannotReachTargetMsg(target)
<a name="636"></a>    { 
<a name="637"></a>        return target.tooFarAwayMsg;
<a name="638"></a>    }
<a name="639"></a>;
<a name="640"></a>
<a name="641"></a>/* 
<a name="642"></a> *   A Door is something that can be open and closed (and optionally locked),
<a name="643"></a> *   and which must be open to allow travel through. Doors are defined in pairs,
<a name="644"></a> *   with each Door representing one side of the door and pointing to the other
<a name="645"></a> *   side via its otherSide property. */
<a name="646"></a>
<a name="647"></a>class Door: TravelConnector, Thing
<a name="648"></a>    
<a name="649"></a>    /* A door is generally openable */
<a name="650"></a>    isOpenable = true
<a name="651"></a>    
<a name="652"></a>    /* Most doors start out closed. */
<a name="653"></a>    isOpen = nil
<a name="654"></a>    
<a name="655"></a>    /* Doors generally aren't listed separately in room descriptions. */
<a name="656"></a>    isListed = nil
<a name="657"></a>    
<a name="658"></a>    /* 
<a name="659"></a>     *   A door is something fixed in place, not something that can be picked up
<a name="660"></a>     *   and carried around.
<a name="661"></a>     */
<a name="662"></a>    isFixed = true
<a name="663"></a>    
<a name="664"></a>    /* 
<a name="665"></a>     *   By default we leave game authors to decide if and how they want to
<a name="666"></a>     *   report whether a door is open or closed.
<a name="667"></a>     */
<a name="668"></a>    openStatusReportable = nil
<a name="669"></a>    
<a name="670"></a>    /*  
<a name="671"></a>     *   Flag, do we want to attempt to unlock this door via an implicit action
<a name="672"></a>     *   if someone attempts to open it while it's locked?
<a name="673"></a>     */
<a name="674"></a>    autoUnlock = nil
<a name="675"></a>    
<a name="676"></a>    /* 
<a name="677"></a>     *   A physical door is represented by two objects in code, each
<a name="678"></a>     *   representing one side of the door and each present in one of the two
<a name="679"></a>     *   locations the door connects. Each side needs to point to the other side
<a name="680"></a>     *   through its otherSide property.
<a name="681"></a>     */    
<a name="682"></a>    otherSide = nil
<a name="683"></a>
<a name="684"></a>    /* 
<a name="685"></a>     *   We're visible in the dark if the room on the other side of us is
<a name="686"></a>     *   illuminated
<a name="687"></a>     */    
<a name="688"></a>    visibleInDark
<a name="689"></a>    {
<a name="690"></a>        if(destination != nil &amp;&amp; transmitsLight)
<a name="691"></a>            return destination.isIlluminated;
<a name="692"></a>        
<a name="693"></a>        return nil;
<a name="694"></a>    }
<a name="695"></a>    
<a name="696"></a>    /*   A Door is something it makes sense to go through. */
<a name="697"></a>    canGoThroughMe = true
<a name="698"></a>    
<a name="699"></a>    /*   Make a Door open (stat = true) or closed (stat = nil) */
<a name="700"></a>    makeOpen(stat)
<a name="701"></a>    {
<a name="702"></a>        /*  Carry out the inherited handling. */
<a name="703"></a>        inherited(stat);
<a name="704"></a>        
<a name="705"></a>        /*  
<a name="706"></a>         *   If we have an otherSide, make it open or closed at the same time so
<a name="707"></a>         *   both sides of the Door stay in sync.
<a name="708"></a>         */
<a name="709"></a>        if(otherSide != nil)
<a name="710"></a>        {
<a name="711"></a>            otherSide.isOpen = stat;
<a name="712"></a>            if(stat)
<a name="713"></a>                otherSide.opened = true;
<a name="714"></a>        }
<a name="715"></a>    }
<a name="716"></a>    
<a name="717"></a>    /*  Make a Door locked (stat = true) or unlocked (stat = nil) */
<a name="718"></a>    makeLocked(stat)
<a name="719"></a>    {
<a name="720"></a>        /* Carry out the inherited handling. */
<a name="721"></a>        inherited(stat);
<a name="722"></a>        
<a name="723"></a>        /* 
<a name="724"></a>         *   If we have an otherSide, make it locked or unlocked at the same
<a name="725"></a>         *   time so both sides of the Door stay in sync.
<a name="726"></a>         */
<a name="727"></a>        if(otherSide != nil)
<a name="728"></a>            otherSide.isLocked = stat;
<a name="729"></a>    }
<a name="730"></a>    
<a name="731"></a>    /*  
<a name="732"></a>     *   The most likely barrier to travel through a door is that the door is
<a name="733"></a>     *   closed and locked, so we check for than after the other kinds of travel
<a name="734"></a>     *   barrier.
<a name="735"></a>     */
<a name="736"></a>    
<a name="737"></a>    checkTravelBarriers(traveler)
<a name="738"></a>    {
<a name="739"></a>        /* 
<a name="740"></a>         *   Carry out the inherited checking of travel barriers and return nil
<a name="741"></a>         *   if they fail to indicate that travel through the door is not
<a name="742"></a>         *   possible.
<a name="743"></a>         */
<a name="744"></a>        if(inherited(traveler) == nil)
<a name="745"></a>            return nil;
<a name="746"></a>        
<a name="747"></a>        /*  If the Door isn't open, try to open it via an implicit action. */
<a name="748"></a>        if(!isOpen)
<a name="749"></a>        {
<a name="750"></a>            /* 
<a name="751"></a>             *   If it's the player character that's trying to move, try opening
<a name="752"></a>             *   the door via an implicit action and display the result as an
<a name="753"></a>             *   implicit action report.
<a name="754"></a>             */
<a name="755"></a>            if(gPlayerChar.isOrIsIn(traveler))
<a name="756"></a>            {
<a name="757"></a>                if(tryImplicitAction(Open, self))
<a name="758"></a>                    "&lt;&lt;gAction.buildImplicitActionAnnouncement(true)&gt;&gt;";
<a name="759"></a>            }
<a name="760"></a>            
<a name="761"></a>            /*   
<a name="762"></a>             *   Otherwise get the traveler to try to open the door via an
<a name="763"></a>             *   implicit action.
<a name="764"></a>             */
<a name="765"></a>            else if(tryImplicitActorAction(traveler, Open, self))
<a name="766"></a>            {                   
<a name="767"></a>                /* 
<a name="768"></a>                 *   If the player character can see the traveler open the door,
<a name="769"></a>                 *   report the fact that the traveler does so.
<a name="770"></a>                 */
<a name="771"></a>                if(gPlayerChar.canSee(traveler))
<a name="772"></a>                    sayTravelerOpensDoor(traveler);
<a name="773"></a>                
<a name="774"></a>                else if(otherSide &amp;&amp; gPlayerChar.canSee(otherSide))                
<a name="775"></a>                    sayDoorOpens();                                
<a name="776"></a>                
<a name="777"></a>            }
<a name="778"></a>            
<a name="779"></a>            /* 
<a name="780"></a>             *   If we're not allowed to open this door via an implicit action
<a name="781"></a>             *   (because opening it is marked as dangerous or nonObvious at the
<a name="782"></a>             *   verify stage) display a message explaining why the travel can't
<a name="783"></a>             *   be carried out, provided the player char can see the traveler.
<a name="784"></a>             */
<a name="785"></a>            
<a name="786"></a>            else if(gPlayerChar.canSee(traveler))            
<a name="787"></a>            {
<a name="788"></a>                local obj = self;
<a name="789"></a>                gMessageParams(obj);                
<a name="790"></a>                
<a name="791"></a>                say(cannotGoThroughClosedDoorMsg);
<a name="792"></a>            }
<a name="793"></a>        }
<a name="794"></a>        
<a name="795"></a>       
<a name="796"></a>        
<a name="797"></a>        /* 
<a name="798"></a>         *   We pass the travel barrier test if and only if the door ends up
<a name="799"></a>         *   open.
<a name="800"></a>         */
<a name="801"></a>        return isOpen;
<a name="802"></a>    }
<a name="803"></a>
<a name="804"></a>    /* 
<a name="805"></a>     *   Message to display when the player character sees the traveler opening
<a name="806"></a>     *   this door.
<a name="807"></a>     */
<a name="808"></a>    sayTravelerOpensDoor(traveler)
<a name="809"></a>    {
<a name="810"></a>        gMessageParams(traveler);
<a name="811"></a>        local obj = self;
<a name="812"></a>        gMessageParams(obj);
<a name="813"></a>        DMsg(npc opens door, '{The subj traveler} open{s/ed} {the
<a name="814"></a>            obj}. ');
<a name="815"></a>        
<a name="816"></a>    }
<a name="817"></a>    
<a name="818"></a>    /* 
<a name="819"></a>     *   Message to display when the door is opened from the other side so the
<a name="820"></a>     *   player character can't see who is opening it.
<a name="821"></a>     */
<a name="822"></a>    sayDoorOpens()
<a name="823"></a>    {
<a name="824"></a>        local obj = otherSide;
<a name="825"></a>        gMessageParams(obj);
<a name="826"></a>        DMsg(door opens, '{The subj obj} open{s/ed}. ');
<a name="827"></a>    }
<a name="828"></a>    
<a name="829"></a>    /*  Execute travel through this door. */
<a name="830"></a>    execTravel(actor, traveler, conn)
<a name="831"></a>    {
<a name="832"></a>        /* 
<a name="833"></a>         *   Carry out the inherited handling (which delegates most of the work
<a name="834"></a>         *   to our destination).
<a name="835"></a>         */
<a name="836"></a>        inherited(actor, traveler, conn);
<a name="837"></a>        
<a name="838"></a>        /*  
<a name="839"></a>         *   If the actor carrying out the travel is the player character, note
<a name="840"></a>         *   that the player character now knows where both sides of the door
<a name="841"></a>         *   lead to.
<a name="842"></a>         */
<a name="843"></a>        if(otherSide != nil &amp;&amp; actor == gPlayerChar &amp;&amp;
<a name="844"></a>           actor.isIn(destination))
<a name="845"></a>        { 
<a name="846"></a>            otherSide.isDestinationKnown = true;
<a name="847"></a>            isDestinationKnown = true;
<a name="848"></a>        }
<a name="849"></a>    }
<a name="850"></a>    
<a name="851"></a>
<a name="852"></a>   
<a name="853"></a>    /*  
<a name="854"></a>     *   The message to display if travel is attempted through this door when
<a name="855"></a>     *   it's closed and we're not allowed to open it via an implicit action.
<a name="856"></a>     */
<a name="857"></a>    cannotGoThroughClosedDoorMsg =  BMsg(cannot go through closed door, 
<a name="858"></a>                                         '{The subj obj} {is} in the way. ')
<a name="859"></a>    
<a name="860"></a>    /*   
<a name="861"></a>     *   By default the player character doesn't start off knowing where this
<a name="862"></a>     *   door leads. Once the pc has been through the door in either direction
<a name="863"></a>     *   this becomes true on both sides of the door.
<a name="864"></a>     */
<a name="865"></a>    isDestinationKnown = nil
<a name="866"></a>   
<a name="867"></a>    /*   Preinitialize a door */
<a name="868"></a>    preinitThing()
<a name="869"></a>    {
<a name="870"></a>        /*  Carry out the inherited handling */
<a name="871"></a>        inherited;
<a name="872"></a>        
<a name="873"></a>        /* 
<a name="874"></a>         *   in addition to carrying out Thing's preinitialization, carry out
<a name="875"></a>         *   some additional housekeeping to ensure that this door is in sync
<a name="876"></a>         *   with its other side.
<a name="877"></a>         */        
<a name="878"></a>        if(otherSide == nil)
<a name="879"></a>        {
<a name="880"></a>            /* 
<a name="881"></a>             *   If the otherSide hasn't been defined and we're compiling for
<a name="882"></a>             *   debugging, display a warning message.
<a name="883"></a>             */
<a name="884"></a>            #ifdef __DEBUG
<a name="885"></a>            "WARNING!!! &lt;&lt;theName&gt;&gt; in &lt;&lt; getOutermostRoom != nil ?
<a name="886"></a>              getOutermostRoom.name : 'nil'&gt;&gt; has no otherside.&lt;.p&gt;";           
<a name="887"></a>            
<a name="888"></a>            #endif
<a name="889"></a>        }
<a name="890"></a>        else
<a name="891"></a>        {
<a name="892"></a>            /* 
<a name="893"></a>             *   If our otherSide doesn't already point to us, make it do so.
<a name="894"></a>             *   This allows game authors to get away with only specifying one
<a name="895"></a>             *   side of the connection.
<a name="896"></a>             */
<a name="897"></a>            if(otherSide.otherSide != self)
<a name="898"></a>                otherSide.otherSide = self;
<a name="899"></a>            
<a name="900"></a>            /*   
<a name="901"></a>             *   If we've made one side of the door locked, the chances are we
<a name="902"></a>             *   intend the other side of the door to start out locked too.
<a name="903"></a>             */
<a name="904"></a>            if(isLocked)
<a name="905"></a>                otherSide.isLocked = true;
<a name="906"></a>            
<a name="907"></a>            
<a name="908"></a>            /*   
<a name="909"></a>             *   Likewise, if we've made one side of the door open, the chances
<a name="910"></a>             *   are we intend the other side of the door to start out open too.
<a name="911"></a>             */
<a name="912"></a>            if(isOpen)
<a name="913"></a>                otherSide.isOpen = true;
<a name="914"></a>            
<a name="915"></a>            /*  Add the other side to our list of facets. */
<a name="916"></a>            getFacets += otherSide;
<a name="917"></a>            
<a name="918"></a>        }       
<a name="919"></a>    }
<a name="920"></a>    
<a name="921"></a>    /*  The destination is the room to which this door leads. */
<a name="922"></a>    destination()
<a name="923"></a>    {
<a name="924"></a>        /*  If we don't have an other side, then we don't lead anywhere. */
<a name="925"></a>        if(otherSide == nil)
<a name="926"></a>            return nil;
<a name="927"></a>            
<a name="928"></a>        
<a name="929"></a>        /* Otherwise this door leads to the room containing its other side */
<a name="930"></a>        return otherSide.getOutermostRoom;
<a name="931"></a>    }
<a name="932"></a>    
<a name="933"></a>    /*  Going through a door is the same as traveling via it. */
<a name="934"></a>    dobjFor(GoThrough)
<a name="935"></a>    {
<a name="936"></a>        action() { travelVia(gActor); }
<a name="937"></a>    }
<a name="938"></a>    
<a name="939"></a>    /*  Entering a door is the same as going through it. */
<a name="940"></a>    dobjFor(Enter) asDobjFor(GoThrough)
<a name="941"></a>        
<a name="942"></a>    
<a name="943"></a>    /*  
<a name="944"></a>     *   The appropriate action for push an object via a door is
<a name="945"></a>     *   PushTravelThrough
<a name="946"></a>     */
<a name="947"></a>    PushTravelVia = PushTravelThrough
<a name="948"></a>    
<a name="949"></a>    /*  
<a name="950"></a>     *   Display message announcing that traveler has left via this door. The
<a name="951"></a>     *   traveler would normally be an NPC visible to the player character.
<a name="952"></a>     */
<a name="953"></a>    sayDeparting(traveler)
<a name="954"></a>    {
<a name="955"></a>        gMessageParams(traveler);
<a name="956"></a>        DMsg(say departing through door, '{The subj traveler} {leaves} through
<a name="957"></a>            {1}. ', theName);
<a name="958"></a>    }
<a name="959"></a>    
<a name="960"></a>    /* 
<a name="961"></a>     *   Display message announcing that follower is following leader through
<a name="962"></a>     *   this door.
<a name="963"></a>     */
<a name="964"></a>    sayActorFollowing(follower, leader)
<a name="965"></a>    {
<a name="966"></a>        /* Create message parameter substitutions for the follower and leader */
<a name="967"></a>        gMessageParams(follower, leader);  
<a name="968"></a>        
<a name="969"></a>        DMsg(say following through door, '{The subj follower} follow{s/ed} {the
<a name="970"></a>            leader} through {1}. ', theName);
<a name="971"></a>    }
<a name="972"></a>    
<a name="973"></a>    traversalMsg = BMsg(traverse door, 'through {1}', theName)
<a name="974"></a>;
<a name="975"></a>
<a name="976"></a>  /* 
<a name="977"></a>   *   A TravelConnector is an object that can be attached to the directional
<a name="978"></a>   *   exit property of a room to facilitate (or optionally block) travel in the
<a name="979"></a>   *   associated direction and carry out any side-effects of that travel. A
<a name="980"></a>   *   TravelConnector may be used as an abstract object to implement travel, or
<a name="981"></a>   *   a subclass of TravelConnector such as Door, Passage, StairwayUp or
<a name="982"></a>   *   StairwayDown may be used to represent a physical object via which travel
<a name="983"></a>   *   occurs. The Room class also inherits from TravelConnector.
<a name="984"></a>   *
<a name="985"></a>   *   Whether the base TravelConnector class or one of its subclasses is used,
<a name="986"></a>   *   travel is carried out via a TravelConnector by calling its travelVia()
<a name="987"></a>   *   method.
<a name="988"></a>   */
<a name="989"></a>class TravelConnector: object    
<a name="990"></a>    
<a name="991"></a>    /* 
<a name="992"></a>     *   Is this connector apparent? That is, would it be apparent to an
<a name="993"></a>     *   observer under normal lighting conditions, as opposed to being
<a name="994"></a>     *   concealed? By default we'll suppose a TravelConnector is apparent
<a name="995"></a>     *   unless it's explicitly hidden.
<a name="996"></a>     */
<a name="997"></a>    isConnectorApparent = !isHidden
<a name="998"></a>    
<a name="999"></a>    /* 
<a name="1000"></a>     *   Should this exit be shown in the exit lister? By default we'll assumed
<a name="1001"></a>     *   it should be it it's visible. 
<a name="1002"></a>     */
<a name="1003"></a>    isConnectorListed = isConnectorVisible
<a name="1004"></a>    
<a name="1005"></a>    /*   
<a name="1006"></a>     *   Does light pass through this TravelConnector from its destination (so
<a name="1007"></a>     *   that it's visible in the dark even its location is dark.).
<a name="1008"></a>     */
<a name="1009"></a>    transmitsLight = true
<a name="1010"></a>    
<a name="1011"></a>    /*  
<a name="1012"></a>     *   A TravelConnector (or at least, the exit it represents) is visible if
<a name="1013"></a>     *   it's apparent (i.e. not concealed in some way) and if the lighting
<a name="1014"></a>     *   conditions are adequate, or if it's visible in the dark.
<a name="1015"></a>     */
<a name="1016"></a>    isConnectorVisible()
<a name="1017"></a>    {
<a name="1018"></a>        local loc = gPlayerChar.getOutermostRoom();
<a name="1019"></a>        local dest = getDestination(loc);
<a name="1020"></a>        return (isConnectorApparent &amp;&amp; 
<a name="1021"></a>                          (loc.isIlluminated
<a name="1022"></a>                              || (dest != nil &amp;&amp; dest.isIlluminated
<a name="1023"></a>                                  &amp;&amp; transmitsLight)
<a name="1024"></a>                           || visibleInDark));
<a name="1025"></a>    }
<a name="1026"></a>    
<a name="1027"></a>    /* The room to which this TravelConnector leads when it is traversed */    
<a name="1028"></a>    destination = nil
<a name="1029"></a>    
<a name="1030"></a>    /* 
<a name="1031"></a>     *   The room to which this TravelConnector leads when it is traversed from
<a name="1032"></a>     *   origin.
<a name="1033"></a>     */    
<a name="1034"></a>    getDestination(origin)
<a name="1035"></a>    {
<a name="1036"></a>        return destination;
<a name="1037"></a>    }
<a name="1038"></a>    
<a name="1039"></a>    /* 
<a name="1040"></a>     *   Does the player char know where this travel connector leads? By default
<a name="1041"></a>     *   s/he doesn't until s/he's visited its destination, but this could be
<a name="1042"></a>     *   overridden for an area the PC is supposed to know well when the game
<a name="1043"></a>     *   starts, such as their own house.
<a name="1044"></a>     */    
<a name="1045"></a>    isDestinationKnown()
<a name="1046"></a>    {
<a name="1047"></a>        local loc = gPlayerChar.getOutermostRoom();
<a name="1048"></a>        local dest = getDestination(loc);
<a name="1049"></a>        return (dest != nil &amp;&amp; dest.isDestinationKnown);
<a name="1050"></a>    }
<a name="1051"></a>    
<a name="1052"></a>    /*   A travel connector is usually open. */
<a name="1053"></a>    isOpen = true
<a name="1054"></a>    
<a name="1055"></a>    /* 
<a name="1056"></a>     *   Carrier out travel via this connector, first checking that travel
<a name="1057"></a>     *   through this connector is permitted for this actor.
<a name="1058"></a>     */    
<a name="1059"></a>    travelVia(actor)
<a name="1060"></a>    {
<a name="1061"></a>        /* 
<a name="1062"></a>         *   The traveler is the object actually doing the travelling; usually
<a name="1063"></a>         *   it's just the actor, but if the actor is in a vehicle, it will be
<a name="1064"></a>         *   the vehicle.
<a name="1065"></a>         */
<a name="1066"></a>        local traveler = getTraveler(actor);       
<a name="1067"></a>        
<a name="1068"></a>        /* 
<a name="1069"></a>         *   Check the travel barriers on this TravelConnector to ensure that
<a name="1070"></a>         *   travel is permitted. If so carry out the travel. If not
<a name="1071"></a>         *   checkTravelBarriers will have reported the reason why travel is
<a name="1072"></a>         *   blocked.
<a name="1073"></a>         */
<a name="1074"></a>        if(checkTravelBarriers(traveler))           
<a name="1075"></a>            execTravel(actor, traveler, self);               
<a name="1076"></a>    }
<a name="1077"></a>    
<a name="1078"></a>   
<a name="1079"></a>    
<a name="1080"></a>    /* 
<a name="1081"></a>     *   Get the traveler associated with this actor. Normally the traveler will
<a name="1082"></a>     *   be the same as the actor, but if the actor is in a vehicle, then the
<a name="1083"></a>     *   traveler will be the vehicle.
<a name="1084"></a>     */
<a name="1085"></a>    getTraveler(actor)
<a name="1086"></a>    {
<a name="1087"></a>        
<a name="1088"></a>        local loc = actor.location;
<a name="1089"></a>        
<a name="1090"></a>        while(loc != nil &amp;&amp; !loc.ofKind(Room))
<a name="1091"></a>        {
<a name="1092"></a>            if(loc.isVehicle)
<a name="1093"></a>                return loc;
<a name="1094"></a>            
<a name="1095"></a>            loc = loc.location;
<a name="1096"></a>        }
<a name="1097"></a>        
<a name="1098"></a>        
<a name="1099"></a>        return actor;
<a name="1100"></a>    }
<a name="1101"></a>    
<a name="1102"></a>    /*  Execute the travel for this actor via this connector */
<a name="1103"></a>    execTravel(actor, traveler, conn)
<a name="1104"></a>    {
<a name="1105"></a>        local loc = traveler.getOutermostRoom();
<a name="1106"></a>        local dest = getDestination(loc);
<a name="1107"></a>        
<a name="1108"></a>        /* If we have a destination, let our destination handle it */
<a name="1109"></a>        if(dest != nil)
<a name="1110"></a>            dest.execTravel(actor, traveler, conn);        
<a name="1111"></a>        
<a name="1112"></a>        else 
<a name="1113"></a>        {    
<a name="1114"></a>            /* 
<a name="1115"></a>             *   Carry out the beforeTravel notifications, since this can't be
<a name="1116"></a>             *   done by our destination, but something in scope may still want
<a name="1117"></a>             *   to react to or prohibit the attempt to travel.
<a name="1118"></a>             */
<a name="1119"></a>            beforeTravelNotifications(actor);
<a name="1120"></a>            
<a name="1121"></a>            /*  
<a name="1122"></a>             *   Then call our noteTraversal method to carry out the
<a name="1123"></a>             *   side-effects of travel; since we don't lead anywhere this may
<a name="1124"></a>             *   be the only reason we exist. If, however, our noteTraversal()
<a name="1125"></a>             *   method fails to display any output, instead display a report
<a name="1126"></a>             *   that this connector doesn't lead anywhere.
<a name="1127"></a>             */
<a name="1128"></a>            if(gOutStream.watchForOutput({:noteTraversal(actor)}) == nil)
<a name="1129"></a>                sayNoDestination();
<a name="1130"></a>        }
<a name="1131"></a>    }
<a name="1132"></a>    
<a name="1133"></a>    /* 
<a name="1134"></a>     *   Display a message saying that this travel connector doesn't actually
<a name="1135"></a>     *   lead anywhere; this may be needed if our destination is nil and our
<a name="1136"></a>     *   noteTraversal() method doesn't display anything.
<a name="1137"></a>     */
<a name="1138"></a>    sayNoDestination()
<a name="1139"></a>    {
<a name="1140"></a>        DMsg(no destination, 'That{dummy} {doesn\'t} lead anywhere. ');
<a name="1141"></a>    }
<a name="1142"></a>
<a name="1143"></a>    
<a name="1144"></a>    
<a name="1145"></a>    /*  
<a name="1146"></a>     *   If the actor doing the traveling is the player character, display the
<a name="1147"></a>     *   travelDesc. Note that although this might normally be a simple
<a name="1148"></a>     *   description of the travel, the travelDesc method could also be used to
<a name="1149"></a>     *   carry out any other side-effects of the travel via this connector.
<a name="1150"></a>     */
<a name="1151"></a>    noteTraversal(actor)
<a name="1152"></a>    {
<a name="1153"></a>        if(actor == gPlayerChar)
<a name="1154"></a>        {                
<a name="1155"></a>            travelDesc;
<a name="1156"></a>            "&lt;.p&gt;";
<a name="1157"></a>        }
<a name="1158"></a>    }
<a name="1159"></a>    
<a name="1160"></a>    
<a name="1161"></a>    /* Carry out the before travel notifications for this actor. */
<a name="1162"></a>    beforeTravelNotifications(actor)
<a name="1163"></a>    {
<a name="1164"></a>        /* 
<a name="1165"></a>         *   Call the before travel notifications on every object that's in
<a name="1166"></a>         *   scope for the actor.
<a name="1167"></a>         */
<a name="1168"></a>        Q.scopeList(actor).toList.forEach({x: x.beforeTravel(actor, self)});
<a name="1169"></a>        
<a name="1170"></a>        
<a name="1171"></a>        
<a name="1172"></a>         /* 
<a name="1173"></a>          *   Finall, carry out before travel notifications in all the regions
<a name="1174"></a>          *   the traveler starts out in.
<a name="1175"></a>          */
<a name="1176"></a>        foreach(local reg in actor.getOutermostRoom.allRegions)
<a name="1177"></a>            reg.regionBeforeTravel(actor, self);
<a name="1178"></a>    }
<a name="1179"></a>    
<a name="1180"></a>    /* Carry out the after travel notifications for this actor */
<a name="1181"></a>    afterTravelNotifications(actor)
<a name="1182"></a>    {
<a name="1183"></a>        /* 
<a name="1184"></a>         *   Call the after travel notification for every object that's in scope
<a name="1185"></a>         *   for this actor.
<a name="1186"></a>         */
<a name="1187"></a>        Q.scopeList(actor).toList.forEach({x: x.afterTravel(actor, self)});
<a name="1188"></a>        
<a name="1189"></a>        /*   
<a name="1190"></a>         *   Finally, carry out after travel notifications in all the regions
<a name="1191"></a>         *   the traveler ends up in.
<a name="1192"></a>         */
<a name="1193"></a>        foreach(local reg in actor.getOutermostRoom.allRegions)
<a name="1194"></a>            reg.regionAfterTravel(actor, self); 
<a name="1195"></a>        
<a name="1196"></a>    }
<a name="1197"></a>
<a name="1198"></a>        
<a name="1199"></a>        
<a name="1200"></a>    /*  
<a name="1201"></a>     *   Method that should return true is actor is allowed to pass through this
<a name="1202"></a>     *   TravelConnector and nil otherwise. We allow travel by default but this
<a name="1203"></a>     *   could be overridden to block travel under certain conditions.
<a name="1204"></a>     */
<a name="1205"></a>    canTravelerPass(actor) { return true; }
<a name="1206"></a>    
<a name="1207"></a>    
<a name="1208"></a>    /*  
<a name="1209"></a>     *   If canTravelerPass returns nil explainTravelBarrier should display a
<a name="1210"></a>     *   message explaining why travel has been prohibited.
<a name="1211"></a>     */
<a name="1212"></a>    explainTravelBarrier(actor) { }
<a name="1213"></a>    
<a name="1214"></a>    /*   
<a name="1215"></a>     *   Carry out any side effects of travel if the traveler is the player
<a name="1216"></a>     *   character. Typically we might just display some text describing the
<a name="1217"></a>     *   travel here, but this method could be used for any side-effects of the
<a name="1218"></a>     *   travel. If the TravelConnector is mixed in with an EventList class then
<a name="1219"></a>     *   the default behaviour is to call the doScript() method here to drive
<a name="1220"></a>     *   the EventList.
<a name="1221"></a>     */
<a name="1222"></a>    travelDesc() 
<a name="1223"></a>    { 
<a name="1224"></a>        if(ofKind(Script))
<a name="1225"></a>            doScript();
<a name="1226"></a>    }
<a name="1227"></a>    
<a name="1228"></a>    /* 
<a name="1229"></a>     *   an additional TravelBarrier or a list of TravelBarriers to check on
<a name="1230"></a>     *   this TravelConnector to see if travel is allowed.
<a name="1231"></a>     */
<a name="1232"></a>    travelBarriers = nil
<a name="1233"></a>       
<a name="1234"></a>    
<a name="1235"></a>    /* 
<a name="1236"></a>     *   Check all the travel barriers associated with this connector to
<a name="1237"></a>     *   determine whether the traveler is allowed to pass through this travel
<a name="1238"></a>     *   connector.
<a name="1239"></a>     */
<a name="1240"></a>    checkTravelBarriers(traveler)
<a name="1241"></a>    {
<a name="1242"></a>        /* first check our own built-in barrier test. */
<a name="1243"></a>        if(!canTravelerPass(traveler))
<a name="1244"></a>        {
<a name="1245"></a>            /* 
<a name="1246"></a>             *   If travel is not permitted display a message explaining why and
<a name="1247"></a>             *   then return nil to cancel the travel.
<a name="1248"></a>             */
<a name="1249"></a>            explainTravelBarrier(traveler);
<a name="1250"></a>            return nil;
<a name="1251"></a>        }
<a name="1252"></a>        
<a name="1253"></a>        /* Then check any additional travel barrier objects */
<a name="1254"></a>        if(valToList(travelBarriers).indexWhich({b: b.checkTravelBarrier
<a name="1255"></a>                                                (traveler,  self) == nil}))
<a name="1256"></a>            return nil;
<a name="1257"></a>        
<a name="1258"></a>        /* 
<a name="1259"></a>         *   If we've reached this point then no travel barrier is objecting to
<a name="1260"></a>         *   the traveler traveling to this connector, so return true to signal
<a name="1261"></a>         *   that travel is permitted.
<a name="1262"></a>         */
<a name="1263"></a>        return true;   
<a name="1264"></a>    }
<a name="1265"></a>    
<a name="1266"></a>    
<a name="1267"></a>    /* 
<a name="1268"></a>     *   Display a message to say that an actor is departing via this connector.
<a name="1269"></a>     *   On the base class the default behaviour is to describe the departure
<a name="1270"></a>     *   via a compass direction. The actor in question would normally be an NPC
<a name="1271"></a>     *   visible to the player character.
<a name="1272"></a>     */
<a name="1273"></a>    sayDeparting(traveler)
<a name="1274"></a>    {       
<a name="1275"></a>        /* Create a message parameter substitution for the traveler */
<a name="1276"></a>        gMessageParams(traveler);        
<a name="1277"></a>        
<a name="1278"></a>        /* Find the direction to which this connector is attached. */
<a name="1279"></a>        local depdir = getDepartingDirection(traveler);
<a name="1280"></a>        
<a name="1281"></a>        if(depdir == nil)
<a name="1282"></a>            DMsg(say departing vague, '&lt;.p&gt;{The subj traveler} {leaves} the
<a name="1283"></a>                area. ');
<a name="1284"></a>        else        
<a name="1285"></a>            DMsg(say departing dir, '&lt;.p&gt;{The subj traveler} {goes} {1}. '
<a name="1286"></a>                 , depdir.departureName);
<a name="1287"></a>                        
<a name="1288"></a>    }
<a name="1289"></a>    
<a name="1290"></a>    /* 
<a name="1291"></a>     *   Display a message to say that follower is following leader in the
<a name="1292"></a>     *   direction of this connector.
<a name="1293"></a>     */
<a name="1294"></a>    sayActorFollowing(follower, leader)
<a name="1295"></a>    {
<a name="1296"></a>        /* Create a message parameter substitution for the traveler */
<a name="1297"></a>        gMessageParams(follower, leader);        
<a name="1298"></a>        
<a name="1299"></a>        /* Find the direction to which this connector is attached. */
<a name="1300"></a>        local depdir = getDepartingDirection(follower);
<a name="1301"></a>        
<a name="1302"></a>        if(depdir == nil)
<a name="1303"></a>            DMsg(say following vague, '&lt;.p&gt;{The subj follower} follow{s/ed} {the
<a name="1304"></a>                leader}. ');
<a name="1305"></a>        else        
<a name="1306"></a>            DMsg(say following dir, '&lt;.p&gt;{The subj follower} follow{s/ed} {the
<a name="1307"></a>                leader} {1}. ', depdir.departureName);
<a name="1308"></a>        
<a name="1309"></a>    }
<a name="1310"></a>    
<a name="1311"></a>    /* 
<a name="1312"></a>     *   Create a phrase describing the direction of travel through this
<a name="1313"></a>     *   connector (e.g. 'to the north')
<a name="1314"></a>     */
<a name="1315"></a>    traversalMsg()
<a name="1316"></a>    {
<a name="1317"></a>        local depDir = getDepartingDirection(gActor);
<a name="1318"></a>        
<a name="1319"></a>        return  BMsg(traverse connector, '{1}', depDir.departureName);
<a name="1320"></a>    }
<a name="1321"></a>    
<a name="1322"></a>   
<a name="1323"></a>    /* 
<a name="1324"></a>     *   Get the direction traveler needs to go in to traverse this connector
<a name="1325"></a>     *   from traveler's current location.
<a name="1326"></a>     */
<a name="1327"></a>    getDepartingDirection(traveler)
<a name="1328"></a>    {                
<a name="1329"></a>        /* Note what room the traveler is in prior to departure */
<a name="1330"></a>        local room = traveler.getOutermostRoom;
<a name="1331"></a>        
<a name="1332"></a>        /* Return the direction to which this connector is attached. */
<a name="1333"></a>        return room.getDirection(self);
<a name="1334"></a>    }
<a name="1335"></a>;
<a name="1336"></a>
<a name="1337"></a>/* 
<a name="1338"></a> *   An UnlistedProxyConnector is a special kind of TravelConnector created by
<a name="1339"></a> *   the asExit macro to make one exit do duty for another. There is probably
<a name="1340"></a> *   never any need for this class to be used explicitly in game code, since
<a name="1341"></a> *   game authors will always use the asExit macro instead.
<a name="1342"></a> */
<a name="1343"></a>class UnlistedProxyConnector: TravelConnector
<a name="1344"></a>    
<a name="1345"></a>    /* An UnlistedProxyConnector is never listed as an exit in its own right. */
<a name="1346"></a>    isConnectorListed = nil
<a name="1347"></a>    
<a name="1348"></a>    /* 
<a name="1349"></a>     *   We'll assume an UnlistedProxyListedConnector is always 'visible', since
<a name="1350"></a>     *   it's a proxy for some other connector which will handle the actual
<a name="1351"></a>     *   visibility conditions.
<a name="1352"></a>     */
<a name="1353"></a>    isConnectorVisible = true
<a name="1354"></a>    
<a name="1355"></a>    /* Carry out travel via this connector. */
<a name="1356"></a>    travelVia(actor)
<a name="1357"></a>    {
<a name="1358"></a>        /* Set up a new travel action. */
<a name="1359"></a>        local action = new TravelAction;
<a name="1360"></a>        
<a name="1361"></a>        /* 
<a name="1362"></a>         *   Set the direction of travel of our new travel action to be the
<a name="1363"></a>         *   direction defined on this UnlistedProxyConnector.
<a name="1364"></a>         */
<a name="1365"></a>        action.direction = direction;
<a name="1366"></a>        
<a name="1367"></a>        /*   
<a name="1368"></a>         *   Get the travel action to carry out the travel in the direction just
<a name="1369"></a>         *   defined.
<a name="1370"></a>         */
<a name="1371"></a>        action.doTravel();
<a name="1372"></a>    }
<a name="1373"></a>    
<a name="1374"></a>    /* Construct a new UnlistedProxyConnector. */
<a name="1375"></a>    construct(dir_)
<a name="1376"></a>    {
<a name="1377"></a>        /* Note the direction this connector is a proxy for. */
<a name="1378"></a>        direction = dir_;        
<a name="1379"></a>        
<a name="1380"></a>    }
<a name="1381"></a>    
<a name="1382"></a>  
<a name="1383"></a>    /* 
<a name="1384"></a>     *   We don't want an UnlistedProxyConnector to trigger any travel
<a name="1385"></a>     *   notifications since these will be triggered - if appropriate - on the
<a name="1386"></a>     *   real connector we point to.     */
<a name="1387"></a>    
<a name="1388"></a>    beforeTravelNotifications(actor) {}    
<a name="1389"></a>    afterTravelNotifications(actor) {}
<a name="1390"></a>    
<a name="1391"></a>
<a name="1392"></a>;
<a name="1393"></a>
<a name="1394"></a>/* 
<a name="1395"></a> *   A TravelBarrier is an object that can optionally be associated with one or
<a name="1396"></a> *   more TravelConnectors to define additional conditional (or even
<a name="1397"></a> *   unconditional) barriers preventing travel.
<a name="1398"></a> */
<a name="1399"></a>class TravelBarrier: object
<a name="1400"></a>    
<a name="1401"></a>    /* 
<a name="1402"></a>     *   This method should return true to permit the traveler to travel via
<a name="1403"></a>     *   connector and nil to prohibit travel. By default we simply allow travel
<a name="1404"></a>     *   but particular instances will need to override this method to specify
<a name="1405"></a>     *   the conditions under which travel is or is not permitted.
<a name="1406"></a>     */
<a name="1407"></a>    canTravelerPass(traveler, connector)
<a name="1408"></a>    {
<a name="1409"></a>        return true;
<a name="1410"></a>    }
<a name="1411"></a>    
<a name="1412"></a>    /*  
<a name="1413"></a>     *   Display some text explaining why traveler is not permitted to travel
<a name="1414"></a>     *   via connector when canTravelerPass() returns nil.
<a name="1415"></a>     */
<a name="1416"></a>    explainTravelBarrier(traveler, connector)
<a name="1417"></a>    {
<a name="1418"></a>    }
<a name="1419"></a>    
<a name="1420"></a>    /* 
<a name="1421"></a>     *   Check whether traveler can pass through this connector. If it can,
<a name="1422"></a>     *   return true; otherise explain why travel is disallowed and return nil.
<a name="1423"></a>     */    
<a name="1424"></a>    checkTravelBarrier(traveler, connector)
<a name="1425"></a>    {
<a name="1426"></a>        if(canTravelerPass(traveler, connector))
<a name="1427"></a>            return true;
<a name="1428"></a>        
<a name="1429"></a>        explainTravelBarrier(traveler, connector);
<a name="1430"></a>        return nil;
<a name="1431"></a>    }
<a name="1432"></a>;
<a name="1433"></a>
<a name="1434"></a>/* 
<a name="1435"></a> *   A Direction object represents a direction in which an actor might attempt
<a name="1436"></a> *   to travel. The library defines eight compass directions (north, south,
<a name="1437"></a> *   etc.) and a further eight special directions (in, out, up, down, port,
<a name="1438"></a> *   starboard, fore and aft), but game code can define additional directions if
<a name="1439"></a> *   required.
<a name="1440"></a> *
<a name="1441"></a> *   The convention that should be followed in naming a Direction object is to
<a name="1442"></a> *   use the name of the direction followed by Dir; e.g. the Direction object
<a name="1443"></a> *   corresponding to north is called northDir. Custom directions should follow
<a name="1444"></a> *   the same convention, since it is assumed by the goInstead() and goNested()
<a name="1445"></a> *   macros.
<a name="1446"></a> */
<a name="1447"></a>class Direction: object
<a name="1448"></a>    
<a name="1449"></a>    /* 
<a name="1450"></a>     *   The exit property of a room association with this Direction, e.g.
<a name="1451"></a>     *   &amp;north (corresponding to northDir).
<a name="1452"></a>     */
<a name="1453"></a>    dirProp = nil
<a name="1454"></a>    
<a name="1455"></a>    /*  
<a name="1456"></a>     *   The name of this direction, e.g. 'north'. This is the name that appears
<a name="1457"></a>     *   in the exit lister.
<a name="1458"></a>     */
<a name="1459"></a>    name = nil
<a name="1460"></a>    
<a name="1461"></a>    /*   Class property: a LookupTable matching names to direction objects. */
<a name="1462"></a>    nameTab = static new LookupTable()
<a name="1463"></a>    
<a name="1464"></a>    /*  
<a name="1465"></a>     *   The name to use when departing via this direction, e.g. 'to the north'
<a name="1466"></a>     */
<a name="1467"></a>    departureName = nil
<a name="1468"></a>    
<a name="1469"></a>    /*
<a name="1470"></a>     *   Initialize.  We'll use this routine to add each Direction instance to
<a name="1471"></a>     *   the master direction list (Direction.allDirections) during
<a name="1472"></a>     *   pre-initialization. 
<a name="1473"></a>     */
<a name="1474"></a>    initializeDirection()
<a name="1475"></a>    {
<a name="1476"></a>        /* add myself to the master direction list */
<a name="1477"></a>        Direction.allDirections.append(self);
<a name="1478"></a>        
<a name="1479"></a>        /* add myself to the master direction table */
<a name="1480"></a>        Direction.nameTab[name] = self;			  
<a name="1481"></a>    }
<a name="1482"></a>
<a name="1483"></a>    /*
<a name="1484"></a>     *   Class initialization - this is called once on the class object.
<a name="1485"></a>     *   We'll build our master list of all of the Direction objects in
<a name="1486"></a>     *   the game, and then sort the list using the sorting order.  
<a name="1487"></a>     */
<a name="1488"></a>    classInit()
<a name="1489"></a>    {
<a name="1490"></a>        /* initialize each individual Direction object */
<a name="1491"></a>        forEachInstance(Direction, { dir: dir.initializeDirection() });
<a name="1492"></a>
<a name="1493"></a>        /* 
<a name="1494"></a>         *   sort the direction list according to the individual Directin
<a name="1495"></a>         *   objects' defined sorting orders 
<a name="1496"></a>         */
<a name="1497"></a>        allDirections.sort(SortAsc, {a, b: a.sortingOrder - b.sortingOrder});
<a name="1498"></a>    }
<a name="1499"></a>
<a name="1500"></a>    /* 
<a name="1501"></a>     *   Our sorting order in the master list.  We use this to present
<a name="1502"></a>     *   directions in a consistent, aesthetically pleasing order in
<a name="1503"></a>     *   listings involving multiple directions.  The sorting order is
<a name="1504"></a>     *   simply an integer that gives the relative position in the list;
<a name="1505"></a>     *   the list of directions is sorted from lowest sorting order to
<a name="1506"></a>     *   highest.  Sorting order numbers don't have to be contiguous,
<a name="1507"></a>     *   since we simply put the directions in an order that makes the
<a name="1508"></a>     *   sortingOrder values ascend through the list.  
<a name="1509"></a>     */
<a name="1510"></a>    sortingOrder = 1
<a name="1511"></a>    
<a name="1512"></a>    /* 
<a name="1513"></a>     *   A Class property containing a Vector of all the directions defined in
<a name="1514"></a>     *   the game (the 16 defined in the library plus any additionasl custom
<a name="1515"></a>     *   directions defined in game code)
<a name="1516"></a>     */
<a name="1517"></a>    allDirections = static new Vector(12)
<a name="1518"></a>   
<a name="1519"></a>    /*   The direction that is opposite to this one. */
<a name="1520"></a>    opposite = nil
<a name="1521"></a>    
<a name="1522"></a>    /*   The dirProp that's the opposite to prop */
<a name="1523"></a>    oppositeProp(prop)
<a name="1524"></a>    {
<a name="1525"></a>        local dir = allDirections.valWhich({d: d.dirProp == prop});
<a name="1526"></a>        
<a name="1527"></a>        return dir == nil ? nil : 
<a name="1528"></a>        (dir.opposite == nil ? nil : dir.opposite.dirProp);
<a name="1529"></a>    }
<a name="1530"></a>        
<a name="1531"></a>	
<a name="1532"></a>;
<a name="1533"></a>
<a name="1534"></a>/* The compass directions */
<a name="1535"></a>class CompassDirection: Direction
<a name="1536"></a>    initializeDirection()
<a name="1537"></a>	{
<a name="1538"></a>	   /* Carry out the inherited handling */
<a name="1539"></a>	   inherited();
<a name="1540"></a>	   
<a name="1541"></a>	   /* Add myself to the list of compass directions */
<a name="1542"></a>	   CompassDirection.compassDirections.append(self);
<a name="1543"></a>	}
<a name="1544"></a>	
<a name="1545"></a>	/* 
<a name="1546"></a>	  * A Class property containing a Vector of all the compass
<a name="1547"></a>	  * directions defined in the game.
<a name="1548"></a>	  */
<a name="1549"></a>	compassDirections = static new Vector(8)
<a name="1550"></a>;
<a name="1551"></a>
<a name="1552"></a>/*  The sixteen directions defined in the library */
<a name="1553"></a>northDir: CompassDirection
<a name="1554"></a>    dirProp = &amp;north
<a name="1555"></a>    name = BMsg(north, 'north')
<a name="1556"></a>    departureName = BMsg(depart north, 'to the north')
<a name="1557"></a>    sortingOrder = 1000
<a name="1558"></a>    opposite = southDir
<a name="1559"></a>;
<a name="1560"></a>
<a name="1561"></a>eastDir: CompassDirection
<a name="1562"></a>    dirProp = &amp;east
<a name="1563"></a>    name = BMsg(east, 'east')
<a name="1564"></a>    departureName = BMsg(depart east, 'to the east')
<a name="1565"></a>    sortingOrder = 1100
<a name="1566"></a>    opposite = westDir
<a name="1567"></a>;
<a name="1568"></a>
<a name="1569"></a>southDir: CompassDirection
<a name="1570"></a>    dirProp = &amp;south
<a name="1571"></a>    name = BMsg(south, 'south')
<a name="1572"></a>    departureName = BMsg(depart south, 'to the south')
<a name="1573"></a>    sortingOrder = 1200
<a name="1574"></a>    opposite = northDir
<a name="1575"></a>;
<a name="1576"></a>
<a name="1577"></a>westDir: CompassDirection
<a name="1578"></a>    dirProp = &amp;west
<a name="1579"></a>    name = BMsg(west, 'west')
<a name="1580"></a>    departureName = BMsg(depart west, 'to the west')
<a name="1581"></a>    sortingOrder = 1300
<a name="1582"></a>    opposite = eastDir
<a name="1583"></a>;
<a name="1584"></a>
<a name="1585"></a>northeastDir: CompassDirection
<a name="1586"></a>    dirProp = &amp;northeast
<a name="1587"></a>    name = BMsg(northeast, 'northeast')
<a name="1588"></a>    departureName = BMsg(depart northeast, 'to the northeast')
<a name="1589"></a>    sortingOrder = 1400
<a name="1590"></a>    opposite = southwestDir
<a name="1591"></a>;
<a name="1592"></a>
<a name="1593"></a>northwestDir: CompassDirection
<a name="1594"></a>    dirProp = &amp;northwest
<a name="1595"></a>    name = BMsg(northwest, 'northwest')
<a name="1596"></a>    departureName = BMsg(depart northwest, 'to the northwest')
<a name="1597"></a>    sortingOrder = 1500
<a name="1598"></a>    opposite = northeastDir
<a name="1599"></a>;
<a name="1600"></a>
<a name="1601"></a>southeastDir: CompassDirection
<a name="1602"></a>    dirProp = &amp;southeast
<a name="1603"></a>    name = BMsg(southeast, 'southeast')
<a name="1604"></a>    departureName = BMsg(depart southeast, 'to the southeast')
<a name="1605"></a>    sortingOrder = 1600
<a name="1606"></a>    opposite = northwestDir
<a name="1607"></a>;
<a name="1608"></a>
<a name="1609"></a>southwestDir: CompassDirection
<a name="1610"></a>    dirProp = &amp;southwest
<a name="1611"></a>    name = BMsg(southwest, 'southwest')
<a name="1612"></a>    departureName = BMsg(depart southwest, 'to the southwest')
<a name="1613"></a>    sortingOrder = 1700
<a name="1614"></a>    opposite = northeastDir
<a name="1615"></a>;
<a name="1616"></a>
<a name="1617"></a>downDir: Direction
<a name="1618"></a>    dirProp = &amp;down
<a name="1619"></a>    name = BMsg(down, 'down')
<a name="1620"></a>    departureName = BMsg(depart down, 'down')
<a name="1621"></a>    sortingOrder = 2000
<a name="1622"></a>    opposite = upDir
<a name="1623"></a>;
<a name="1624"></a>
<a name="1625"></a>upDir: Direction
<a name="1626"></a>    dirProp = &amp;up
<a name="1627"></a>    name = BMsg(up, 'up')
<a name="1628"></a>    departureName = BMsg(depart up, 'up')
<a name="1629"></a>    sortingOrder = 2100
<a name="1630"></a>    opposite = downDir
<a name="1631"></a>;
<a name="1632"></a>
<a name="1633"></a>inDir: Direction
<a name="1634"></a>    dirProp = &amp;in
<a name="1635"></a>    name = BMsg(in, 'in')
<a name="1636"></a>    departureName = BMsg(depart in, 'inside')
<a name="1637"></a>    sortingOrder = 3000
<a name="1638"></a>    opposite = outDir
<a name="1639"></a>;
<a name="1640"></a>
<a name="1641"></a>outDir: Direction
<a name="1642"></a>    dirProp = &amp;out
<a name="1643"></a>    name = BMsg(out, 'out')
<a name="1644"></a>    departureName = BMsg(depart out, 'out')
<a name="1645"></a>    sortingOrder = 3100
<a name="1646"></a>    opposite = inDir
<a name="1647"></a>;
<a name="1648"></a>
<a name="1649"></a>/* Directions for use aboard a vessel such as a ship */
<a name="1650"></a>class ShipboardDirection: Direction
<a name="1651"></a>    initializeDirection()
<a name="1652"></a>	{
<a name="1653"></a>	   /* Carry out the inherited handling */
<a name="1654"></a>	   inherited();
<a name="1655"></a>	   
<a name="1656"></a>	   /* Add myself to the list of shipboard directions */
<a name="1657"></a>	   ShipboardDirection.shipboardDirections.append(self);
<a name="1658"></a>	} 
<a name="1659"></a>    
<a name="1660"></a>
<a name="1661"></a>    /* 
<a name="1662"></a>	  * A Class property containing a Vector of all the shipboard
<a name="1663"></a>	  * directions defined in the game.
<a name="1664"></a>	  */
<a name="1665"></a>	shipboardDirections = static new Vector (4)
<a name="1666"></a>;
<a name="1667"></a>
<a name="1668"></a>portDir: ShipboardDirection
<a name="1669"></a>    dirProp = &amp;port
<a name="1670"></a>    name = BMsg(port, 'port')
<a name="1671"></a>    departureName = BMsg(depart port, 'to port')
<a name="1672"></a>    sortingOrder = 4000
<a name="1673"></a>    opposite = starboardDir
<a name="1674"></a>;
<a name="1675"></a>
<a name="1676"></a>starboardDir: ShipboardDirection
<a name="1677"></a>    dirProp = &amp;starboard
<a name="1678"></a>    name = BMsg(starboard, 'starboard')
<a name="1679"></a>    departureName = BMsg(depart starboard, 'to starboard')
<a name="1680"></a>    sortingOrder = 4100
<a name="1681"></a>    opposite = portDir
<a name="1682"></a>;
<a name="1683"></a>
<a name="1684"></a>foreDir: ShipboardDirection
<a name="1685"></a>    dirProp = &amp;fore
<a name="1686"></a>    name = BMsg(forward, 'forward')
<a name="1687"></a>    departureName = BMsg(depart forward, 'forward')
<a name="1688"></a>    sortingOrder = 4200
<a name="1689"></a>    opposite = aftDir
<a name="1690"></a>;
<a name="1691"></a>
<a name="1692"></a>aftDir: ShipboardDirection
<a name="1693"></a>    dirProp = &amp;aft
<a name="1694"></a>    name = BMsg(aft, 'aft')
<a name="1695"></a>    departureName = BMsg(depart aft, 'aft')
<a name="1696"></a>    sortingOrder = 4300
<a name="1697"></a>    opposite = foreDir
<a name="1698"></a>;
<a name="1699"></a>
<a name="1700"></a>/*  
<a name="1701"></a> *   A Region is an object representing several rooms or even several other
<a name="1702"></a> *   Regions.
<a name="1703"></a> */
<a name="1704"></a>class Region: object
<a name="1705"></a>    
<a name="1706"></a>    /* 
<a name="1707"></a>     *   This region can optionally be in one or more regions. The regions
<a name="1708"></a>     *   property hold the region or a the list of regions I'm in.
<a name="1709"></a>     */    
<a name="1710"></a>    regions = nil
<a name="1711"></a>    
<a name="1712"></a>    /* 
<a name="1713"></a>     *   A Room can't be in another Room or a Thing, but it can notionally be in
<a name="1714"></a>     *   a Region, so we check to see if we're in the list of our regions.
<a name="1715"></a>     */    
<a name="1716"></a>    isIn(region)
<a name="1717"></a>    {               
<a name="1718"></a>        return valToList(regions).indexWhich({x: x.isOrIsIn(region)}) != nil;
<a name="1719"></a>    }
<a name="1720"></a>    
<a name="1721"></a>    /*  Is this Region either itself region or contained within in region */
<a name="1722"></a>    isOrIsIn(region)
<a name="1723"></a>    {
<a name="1724"></a>        return region == self || isIn(region); 
<a name="1725"></a>    }
<a name="1726"></a>    
<a name="1727"></a>    /* 
<a name="1728"></a>     *   A list of all the regions this Region is within; in addition to any
<a name="1729"></a>     *   regions this Region is directly in (defined on its regions property)
<a name="1730"></a>     *   this will include all the regions it's indirectly in (i.e. any regions
<a name="1731"></a>     *   the regions it's in are in and so forth).
<a name="1732"></a>     */
<a name="1733"></a>    allRegions()
<a name="1734"></a>    {
<a name="1735"></a>        /* Start with a vector of all the regions we're directly in */
<a name="1736"></a>        local thisRegions = new Vector(valToList(regions));
<a name="1737"></a>        
<a name="1738"></a>        /* 
<a name="1739"></a>         *   For each of the regions we're directly in, append all the regions
<a name="1740"></a>         *   they're in.
<a name="1741"></a>         */
<a name="1742"></a>        foreach(local reg in valToList(regions))
<a name="1743"></a>            thisRegions.appendUnique(reg.allRegions);
<a name="1744"></a>        
<a name="1745"></a>        /*   Convert the Vector to a list and return it. */
<a name="1746"></a>        return thisRegions.toList();
<a name="1747"></a>    }
<a name="1748"></a>    
<a name="1749"></a>    /* 
<a name="1750"></a>     *   A list of all the rooms in this region. This is built automatically at
<a name="1751"></a>     *   preinit and shouldn't be altered by the user/author.
<a name="1752"></a>     */    
<a name="1753"></a>    roomList = nil
<a name="1754"></a>    
<a name="1755"></a>    /*   
<a name="1756"></a>     *   A user-defined list of the rooms in this region. At Preinit this will
<a name="1757"></a>     *   be used along with the regions property of any rooms to build the
<a name="1758"></a>     *   roomList of this Region.
<a name="1759"></a>     */
<a name="1760"></a>    rooms = nil
<a name="1761"></a>       
<a name="1762"></a>    /* 
<a name="1763"></a>     *   Build the list of regions in all the rooms in this this region by going
<a name="1764"></a>     *   through every room defined in the roomList and adding us to its list of
<a name="1765"></a>     *   regions. Note that this is provided as an alternative way to define
<a name="1766"></a>     *   what rooms start out in which regions.     
<a name="1767"></a>     */
<a name="1768"></a>    
<a name="1769"></a>    makeRegionLists()
<a name="1770"></a>    {       
<a name="1771"></a>        if(rooms != nil)
<a name="1772"></a>        {
<a name="1773"></a>            foreach(local r in rooms)
<a name="1774"></a>                r.regions = valToList(r.regions).appendUnique([self]);
<a name="1775"></a>        }       
<a name="1776"></a>    }
<a name="1777"></a>    
<a name="1778"></a>    /* 
<a name="1779"></a>     *   Is the player char familiar with every room in this region. This should
<a name="1780"></a>     *   be set to true for a region whose geography the PC starts out familiar
<a name="1781"></a>     *   with, such as the layout of his own house.
<a name="1782"></a>     */    
<a name="1783"></a>    familiar = nil
<a name="1784"></a>    
<a name="1785"></a>    /* 
<a name="1786"></a>     *   Go through all the rooms in this region setting them to familiar if the
<a name="1787"></a>     *   region is familiar.
<a name="1788"></a>     */    
<a name="1789"></a>    setFamiliarRooms()
<a name="1790"></a>    {
<a name="1791"></a>        if(familiar)
<a name="1792"></a>        {
<a name="1793"></a>            /* 
<a name="1794"></a>             *   If this Region is familiar then go through each room in the
<a name="1795"></a>             *   list of rooms in the Region and mark it as familiar.
<a name="1796"></a>             */
<a name="1797"></a>            foreach(local rm in valToList(roomList))
<a name="1798"></a>            {
<a name="1799"></a>                rm.familiar = true;                
<a name="1800"></a>            }
<a name="1801"></a>        }
<a name="1802"></a>    }
<a name="1803"></a>    
<a name="1804"></a>        
<a name="1805"></a>    /* 
<a name="1806"></a>     *   To add an object to our contents we need to add it to the contents of
<a name="1807"></a>     *   every room in this region. If the optional vec parameter is supplied it
<a name="1808"></a>     *   must be a vector; the rooms will then be added to the vector as well.
<a name="1809"></a>     *   The vec parameter is primarily for use by the MultiLoc class.
<a name="1810"></a>     */    
<a name="1811"></a>    addToContents(obj, vec?)
<a name="1812"></a>    {
<a name="1813"></a>        foreach(local cur in roomList)
<a name="1814"></a>        {
<a name="1815"></a>            cur.addToContents(obj, vec);
<a name="1816"></a>        }
<a name="1817"></a>    }
<a name="1818"></a>    
<a name="1819"></a>    /* 
<a name="1820"></a>     *   To remove an object from our contents we need to remove it from the
<a name="1821"></a>     *   contents of every room in the region. If the optional vec parameter is
<a name="1822"></a>     *   supplied it must be a vector; the rooms will then be removed from the
<a name="1823"></a>     *   vector as well.
<a name="1824"></a>     */         
<a name="1825"></a>    removeFromContents(obj, vec?)
<a name="1826"></a>    {
<a name="1827"></a>        foreach(local cur in roomList)
<a name="1828"></a>        {
<a name="1829"></a>            cur.removeFromContents(obj, vec);
<a name="1830"></a>        }
<a name="1831"></a>    }
<a name="1832"></a>    
<a name="1833"></a>    /* 
<a name="1834"></a>     *   Add an additional room (passed as the rm parameter) to our list of
<a name="1835"></a>     *   rooms. This method is intended for internal library use at PreInit
<a name="1836"></a>     *   only.
<a name="1837"></a>     */
<a name="1838"></a>    addToRoomList(rm)
<a name="1839"></a>    {
<a name="1840"></a>        /* 
<a name="1841"></a>         *   Add rm to our existing roomList, making sure we don't duplicate an
<a name="1842"></a>         *   existing entry, and converting the roomList from nil to a list if
<a name="1843"></a>         *   isn't a list already.
<a name="1844"></a>         */
<a name="1845"></a>        roomList = nilToList(roomList).appendUnique([rm]);
<a name="1846"></a>        
<a name="1847"></a>        /*  Add rm to the room list of all the regions we're in */
<a name="1848"></a>        foreach(local cur in valToList(regions))
<a name="1849"></a>            cur.addToRoomList(rm);
<a name="1850"></a>    }
<a name="1851"></a>    
<a name="1852"></a>    /* 
<a name="1853"></a>     *   Put extra items in scope when action is carried out in any room in this
<a name="1854"></a>     *   region.
<a name="1855"></a>     */
<a name="1856"></a>    addExtraScopeItems(action)
<a name="1857"></a>    {
<a name="1858"></a>        /* 
<a name="1859"></a>         *   Add our list of extraScopeItems to the existing scopeList of the
<a name="1860"></a>         *   action, avoiding creating any duplicate entries.
<a name="1861"></a>         */
<a name="1862"></a>        action.scopeList =
<a name="1863"></a>            action.scopeList.appendUnique(valToList(extraScopeItems));
<a name="1864"></a>        
<a name="1865"></a>        /* 
<a name="1866"></a>         *   Add any further additional scope items from any of the regions
<a name="1867"></a>         *   that this region is in.
<a name="1868"></a>         */
<a name="1869"></a>        foreach(local reg in valToList(regions))
<a name="1870"></a>            reg.addExtraScopeItems(action);
<a name="1871"></a>    }
<a name="1872"></a>    
<a name="1873"></a>    /* 
<a name="1874"></a>     *   A list of items that should be added to the standard scope list for
<a name="1875"></a>     *   actions carried out in any room in this region.
<a name="1876"></a>     */
<a name="1877"></a>    extraScopeItems = []
<a name="1878"></a>    
<a name="1879"></a>     /* 
<a name="1880"></a>      *   This method is invoked when traveler is about to leave this region and
<a name="1881"></a>      *   go to dest (the destination room).
<a name="1882"></a>      */
<a name="1883"></a>    travelerLeaving(traveler, dest) { }
<a name="1884"></a>    
<a name="1885"></a>     /* 
<a name="1886"></a>      *   This method is invoked when traveler is about to enter this region
<a name="1887"></a>      *   from origin (the room traveled from.
<a name="1888"></a>      */    
<a name="1889"></a>    travelerEntering(traveler, origin) { }
<a name="1890"></a>    
<a name="1891"></a>    /* Carry out before notifications on the region */
<a name="1892"></a>    notifyBefore()
<a name="1893"></a>    {
<a name="1894"></a>        /* First call our own regionBeforeAction() method */
<a name="1895"></a>        regionBeforeAction();
<a name="1896"></a>        
<a name="1897"></a>        /* 
<a name="1898"></a>         *   Then call the beforeAction notification on all the regions we're
<a name="1899"></a>         *   in.
<a name="1900"></a>         */
<a name="1901"></a>        foreach(local reg in valToList(regions))
<a name="1902"></a>            reg.notifyBefore();
<a name="1903"></a>    }
<a name="1904"></a>    
<a name="1905"></a>    /* 
<a name="1906"></a>     *   This method is called just before an action takes places in this
<a name="1907"></a>     *   region.
<a name="1908"></a>     */
<a name="1909"></a>    regionBeforeAction() { }
<a name="1910"></a>    
<a name="1911"></a>    /* Carry out after notifications on the region */
<a name="1912"></a>    notifyAfter()
<a name="1913"></a>    {
<a name="1914"></a>        /* First call our own regionAfterAction() method */
<a name="1915"></a>        regionAfterAction();
<a name="1916"></a>        
<a name="1917"></a>        /* 
<a name="1918"></a>         *   Then call the afterAction notification on all the regions we're
<a name="1919"></a>         *   in.
<a name="1920"></a>         */
<a name="1921"></a>        foreach(local reg in valToList(regions))
<a name="1922"></a>            reg.notifyAfter();
<a name="1923"></a>    }
<a name="1924"></a>    
<a name="1925"></a>    /* Method called just after an action has taken place in this region. */
<a name="1926"></a>    regionAfterAction() { }
<a name="1927"></a>    
<a name="1928"></a>    /* 
<a name="1929"></a>     *   This method is called just before travel takes places in this
<a name="1930"></a>     *   region (when traveler is about to travel via connector).
<a name="1931"></a>     */
<a name="1932"></a>    regionBeforeTravel(traveler, connector) { }       
<a name="1933"></a>   
<a name="1934"></a>    
<a name="1935"></a>    /* 
<a name="1936"></a>     *   Method called just after travel has taken place in this region (when
<a name="1937"></a>     *   traveler has just traveled via connector).
<a name="1938"></a>     */
<a name="1939"></a>    regionAfterTravel(traveler, connector) { }
<a name="1940"></a>    
<a name="1941"></a>    /*   
<a name="1942"></a>     *   Should the fastGoTo option be used in this region (i.e. traveling from
<a name="1943"></a>     *   one room in the region to another is all done in one turn without the
<a name="1944"></a>     *   need for CONTINUE, even if several steps are involved)? Note that the
<a name="1945"></a>     *   value of this setting has no effect if gameMain.fastGoTo is true, since
<a name="1946"></a>     *   then the fastGoTo setting is always in effect.
<a name="1947"></a>     */
<a name="1948"></a>    fastGoTo = nil
<a name="1949"></a>    
<a name="1950"></a>    /* 
<a name="1951"></a>     *   Move a MultiLoc (ml) into this region, by moving it into every room in
<a name="1952"></a>     *   this Region.
<a name="1953"></a>     */
<a name="1954"></a>    moveMLIntoAdd(ml)
<a name="1955"></a>    {
<a name="1956"></a>        roomList.forEach({r: ml.moveIntoAdd(r)});
<a name="1957"></a>    }
<a name="1958"></a>    
<a name="1959"></a>    /*  
<a name="1960"></a>     *   Move a MultiLoc (ml) out of this region, by moving it out of every room
<a name="1961"></a>     *   in the Region.
<a name="1962"></a>     */
<a name="1963"></a>    moveMLOutOf(ml)
<a name="1964"></a>    {
<a name="1965"></a>        roomList.forEach({r: ml.moveOutOf(r)});
<a name="1966"></a>    }
<a name="1967"></a>;
<a name="1968"></a>
<a name="1969"></a>/* 
<a name="1970"></a> *   Go through each room and add it to every regions it's (directly or
<a name="1971"></a> *   indirectly) in. Then if the region is familiar, mark all its rooms as
<a name="1972"></a> *   familiar.
<a name="1973"></a> */
<a name="1974"></a>regionPreinit: PreinitObject    
<a name="1975"></a>    execute()
<a name="1976"></a>    {
<a name="1977"></a>        forEachInstance(Region, {r: r.makeRegionLists });
<a name="1978"></a>        
<a name="1979"></a>        forEachInstance(Room, {r: r.addToRegions()} );
<a name="1980"></a>        
<a name="1981"></a>        forEachInstance(Region, { r: r.setFamiliarRooms() } );
<a name="1982"></a>    }
<a name="1983"></a>    
<a name="1984"></a>;
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 28/03/2016 from adv3Lite version 1.5</div>
</body>
</html>
