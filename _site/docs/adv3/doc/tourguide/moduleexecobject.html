<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:type" content="website">
    <link rel="icon" href="/assets/images/tads-favicon.png" type="image/png">
    <link rel="stylesheet" type="text/css"
                           href="/assets/css/styles.css">
    <title></title>
    <meta property="og:title" content=
    "">
    <meta name="description" content="">
    <meta property="og:description" content="">
</head>
<header id="header"><div class="header-search">
    <form class="header-search-form" action="/search" method="get">
      <input type="text" id="search-box" name="query">
      <input type="submit" value="search">
    </form>
  </div>  </header>
<body>
<main id="content">
<table width="100%" data-border="0" data-cellspacing="0" data-cellpadding="3" data-bgcolor="#C0C0C0">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr>
<td style="text-align: left;"><strong>ModuleExecObject<br />
</strong></td>
<td style="text-align: right;"><a href="onetimepromptdaemon.html">[Previous]</a> <a href="generalintroduction.html">[Main]</a> <a href="initobject.html">[Next]</a></td>
</tr>
</tbody>
</table>

<p>ModuleExecObjects are a little like Fuses and Daemons in that they allow
code to be executed at a particular point, although a ModuleExecObject
is not the really same thing as a Fuse or Daemon. Instead,
ModuleExecObject is an abstract base class for various classes that
provide modular execution hooks. This class and its subclasses are
mix-in classes - they can be multiply inherited by any object (as long
as it’s not already some other kind of module execution object).</p>

<p>The point of the Module Execution Object and its subclasses is to allow
libraries and user code to define execution hooks, without having to
worry about what other libraries and user code bits are defining the
same hook. When we need to execute a hook defined via this object, we
iterate over all of the instances of the appropriate subclass and invoke
its execute() method.</p>

<p>By default, the order of execution is arbitrary. In some cases, though,
dependencies will exist, so that one object cannot be invoked until
another object has already been invoked. In these cases, you must set
the execBeforeMe property to contain a list of the objects whose
execute() methods must be invoked before this object’s execute() method
is invoked. The library will check this list before calling execute() on
this object, and ensure that each object in the list has been invoked
before calling this object’s execute(). Similarly, you can use the
execAfterMe property to contain a list of all the ModuleExecObjects that
mustn’t execute until the current object has executed.</p>


</main>
<footer id="footer">
    <p>This is an unofficial informational website to aggregate TADS 3 information and does not claim authorship over, or any rights to, TADS 3 itself. All resources copyright their credited owners. TADS itself is <a href="https://www.tads.org/copyright.htm">Copyright ©2001-2013 Michael J. Roberts</a>.</p>
    <p><a href="/">Back to Homepage</a></p>
</footer>
</body>
</html>

<script>
    if(window.location !== window.top.location) {
        let header = document.getElementById('header');
        let footer = document.getElementById('footer');
        header.remove();
        footer.remove();
    }
</script>